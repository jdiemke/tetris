/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/jsxm/xm.js":
/*!*********************************!*\
  !*** ./node_modules/jsxm/xm.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function (window) {\n    if (!window.XMPlayer) {\n        window.XMPlayer = {};\n    }\n    var player = window.XMPlayer;\n    if (!window.XMView) {\n        window.XMView = {};\n    }\n    var XMView = window.XMView;\n    player.periodForNote = periodForNote;\n    player.prettify_effect = prettify_effect;\n    player.init = init;\n    player.load = load;\n    player.play = play;\n    player.pause = pause;\n    player.stop = stop;\n    player.cur_songpos = -1;\n    player.cur_pat = -1;\n    player.cur_row = 64;\n    player.cur_ticksamp = 0;\n    player.cur_tick = 6;\n    player.xm = {}; // contains all song data\n    player.xm.global_volume = player.max_global_volume = 128;\n    // exposed for testing\n    player.nextTick = nextTick;\n    player.nextRow = nextRow;\n    player.Envelope = Envelope;\n    // for pretty-printing notes\n    var _note_names = [\n        \"C-\", \"C#\", \"D-\", \"D#\", \"E-\", \"F-\",\n        \"F#\", \"G-\", \"G#\", \"A-\", \"A#\", \"B-\"\n    ];\n    var f_smp = 44100; // updated by play callback, default value here\n    // per-sample exponential moving average for volume changes (to prevent pops\n    // and clicks); evaluated every 8 samples\n    var popfilter_alpha = 0.9837;\n    function prettify_note(note) {\n        if (note < 0)\n            return \"---\";\n        if (note == 96)\n            return \"^^^\";\n        return _note_names[note % 12] + ~~(note / 12);\n    }\n    function prettify_number(num) {\n        if (num == -1)\n            return \"--\";\n        if (num < 10)\n            return \"0\" + num;\n        return num;\n    }\n    function prettify_volume(num) {\n        if (num < 0x10)\n            return \"--\";\n        return num.toString(16);\n    }\n    function prettify_effect(t, p) {\n        if (t >= 10)\n            t = String.fromCharCode(55 + t);\n        if (p < 16)\n            p = '0' + p.toString(16);\n        else\n            p = p.toString(16);\n        return t + p;\n    }\n    function prettify_notedata(data) {\n        return (prettify_note(data[0]) + \" \" + prettify_number(data[1]) + \" \" +\n            prettify_volume(data[2]) + \" \" +\n            prettify_effect(data[3], data[4]));\n    }\n    function getstring(dv, offset, len) {\n        var str = [];\n        for (var i = offset; i < offset + len; i++) {\n            var c = dv.getUint8(i);\n            if (c === 0)\n                break;\n            str.push(String.fromCharCode(c));\n        }\n        return str.join('');\n    }\n    // Return 2-pole Butterworth lowpass filter coefficients for\n    // center frequncy f_c (relative to sampling frequency)\n    function filterCoeffs(f_c) {\n        if (f_c > 0.5) { // we can't lowpass above the nyquist frequency...\n            f_c = 0.5;\n        }\n        var wct = Math.sqrt(2) * Math.PI * f_c;\n        var e = Math.exp(-wct);\n        var c = e * Math.cos(wct);\n        var gain = (1 - 2 * c + e * e) / 2;\n        return [gain, 2 * c, -e * e];\n    }\n    function updateChannelPeriod(ch, period) {\n        var freq = 8363 * Math.pow(2, (1152.0 - period) / 192.0);\n        if (isNaN(freq)) {\n            console.log(\"invalid period!\", period);\n            return;\n        }\n        ch.doff = freq / f_smp;\n        ch.filter = filterCoeffs(ch.doff / 2);\n    }\n    function periodForNote(ch, note) {\n        return 1920 - (note + ch.samp.note) * 16 - ch.fine / 8.0;\n    }\n    function setCurrentPattern() {\n        var nextPat = player.xm.songpats[player.cur_songpos];\n        // check for out of range pattern index\n        while (nextPat >= player.xm.patterns.length) {\n            if (player.cur_songpos + 1 < player.xm.songpats.length) {\n                // first try skipping the position\n                player.cur_songpos++;\n            }\n            else if ((player.cur_songpos === player.xm.song_looppos && player.cur_songpos !== 0)\n                || player.xm.song_looppos >= player.xm.songpats.length) {\n                // if we allready tried song_looppos or if song_looppos\n                // is out of range, go to the first position\n                player.cur_songpos = 0;\n            }\n            else {\n                // try going to song_looppos\n                player.cur_songpos = player.xm.song_looppos;\n            }\n            nextPat = player.xm.songpats[player.cur_songpos];\n        }\n        player.cur_pat = nextPat;\n    }\n    function nextRow() {\n        if (typeof player.next_row === \"undefined\") {\n            player.next_row = player.cur_row + 1;\n        }\n        player.cur_row = player.next_row;\n        player.next_row++;\n        if (player.cur_pat == -1 || player.cur_row >= player.xm.patterns[player.cur_pat].length) {\n            player.cur_row = 0;\n            player.next_row = 1;\n            player.cur_songpos++;\n            if (player.cur_songpos >= player.xm.songpats.length)\n                player.cur_songpos = player.xm.song_looppos;\n            setCurrentPattern();\n        }\n        var p = player.xm.patterns[player.cur_pat];\n        var r = p[player.cur_row];\n        for (var i = 0; i < r.length; i++) {\n            var ch = player.xm.channelinfo[i];\n            var inst = ch.inst;\n            var triggernote = false;\n            // instrument trigger\n            if (r[i][1] != -1) {\n                inst = player.xm.instruments[r[i][1] - 1];\n                if (inst && inst.samplemap) {\n                    ch.inst = inst;\n                    // retrigger unless overridden below\n                    triggernote = true;\n                    if (ch.note && inst.samplemap) {\n                        ch.samp = inst.samples[inst.samplemap[ch.note]];\n                        ch.vol = ch.samp.vol;\n                        ch.pan = ch.samp.pan;\n                        ch.fine = ch.samp.fine;\n                    }\n                }\n                else {\n                    // console.log(\"invalid inst\", r[i][1], instruments.length);\n                }\n            }\n            // note trigger\n            if (r[i][0] != -1) {\n                if (r[i][0] == 96) {\n                    ch.release = 1;\n                    triggernote = false;\n                }\n                else {\n                    if (inst && inst.samplemap) {\n                        var note = r[i][0];\n                        ch.note = note;\n                        ch.samp = inst.samples[inst.samplemap[ch.note]];\n                        if (triggernote) {\n                            // if we were already triggering the note, reset vol/pan using\n                            // (potentially) new sample\n                            ch.pan = ch.samp.pan;\n                            ch.vol = ch.samp.vol;\n                            ch.fine = ch.samp.fine;\n                        }\n                        triggernote = true;\n                    }\n                }\n            }\n            ch.voleffectfn = undefined;\n            if (r[i][2] != -1) { // volume column\n                var v = r[i][2];\n                ch.voleffectdata = v & 0x0f;\n                if (v < 0x10) {\n                    console.log(\"channel\", i, \"invalid volume\", v.toString(16));\n                }\n                else if (v <= 0x50) {\n                    ch.vol = v - 0x10;\n                }\n                else if (v >= 0x60 && v < 0x70) { // volume slide down\n                    ch.voleffectfn = function (ch) {\n                        ch.vol = Math.max(0, ch.vol - ch.voleffectdata);\n                    };\n                }\n                else if (v >= 0x70 && v < 0x80) { // volume slide up\n                    ch.voleffectfn = function (ch) {\n                        ch.vol = Math.min(64, ch.vol + ch.voleffectdata);\n                    };\n                }\n                else if (v >= 0x80 && v < 0x90) { // fine volume slide down\n                    ch.vol = Math.max(0, ch.vol - (v & 0x0f));\n                }\n                else if (v >= 0x90 && v < 0xa0) { // fine volume slide up\n                    ch.vol = Math.min(64, ch.vol + (v & 0x0f));\n                }\n                else if (v >= 0xa0 && v < 0xb0) { // vibrato speed\n                    ch.vibratospeed = v & 0x0f;\n                }\n                else if (v >= 0xb0 && v < 0xc0) { // vibrato w/ depth\n                    ch.vibratodepth = v & 0x0f;\n                    ch.voleffectfn = player.effects_t1[4]; // use vibrato effect directly\n                    player.effects_t1[4](ch); // and also call it on tick 0\n                }\n                else if (v >= 0xc0 && v < 0xd0) { // set panning\n                    ch.pan = (v & 0x0f) * 0x11;\n                }\n                else if (v >= 0xf0 && v <= 0xff) { // portamento\n                    if (v & 0x0f) {\n                        ch.portaspeed = (v & 0x0f) << 4;\n                    }\n                    ch.voleffectfn = player.effects_t1[3]; // just run 3x0\n                }\n                else {\n                    console.log(\"channel\", i, \"volume effect\", v.toString(16));\n                }\n            }\n            ch.effect = r[i][3];\n            ch.effectdata = r[i][4];\n            if (ch.effect < 36) {\n                ch.effectfn = player.effects_t1[ch.effect];\n                var eff_t0 = player.effects_t0[ch.effect];\n                if (eff_t0 && eff_t0(ch, ch.effectdata)) {\n                    triggernote = false;\n                }\n            }\n            else {\n                console.log(\"channel\", i, \"effect > 36\", ch.effect);\n            }\n            // special handling for portamentos: don't trigger the note\n            if (ch.effect == 3 || ch.effect == 5 || r[i][2] >= 0xf0) {\n                if (r[i][0] != -1) {\n                    ch.periodtarget = periodForNote(ch, ch.note);\n                }\n                triggernote = false;\n                if (inst && inst.samplemap) {\n                    if (ch.env_vol == undefined) {\n                        // note wasn't already playing; we basically have to ignore the\n                        // portamento and just trigger\n                        triggernote = true;\n                    }\n                    else if (ch.release) {\n                        // reset envelopes if note was released but leave offset/pitch/etc\n                        // alone\n                        ch.envtick = 0;\n                        ch.release = 0;\n                        ch.env_vol = new EnvelopeFollower(inst.env_vol);\n                        ch.env_pan = new EnvelopeFollower(inst.env_pan);\n                    }\n                }\n            }\n            if (triggernote) {\n                // there's gotta be a less hacky way to handle offset commands...\n                if (ch.effect != 9)\n                    ch.off = 0;\n                ch.release = 0;\n                ch.envtick = 0;\n                ch.env_vol = new EnvelopeFollower(inst.env_vol);\n                ch.env_pan = new EnvelopeFollower(inst.env_pan);\n                if (ch.note) {\n                    ch.period = periodForNote(ch, ch.note);\n                }\n                // waveforms 0-3 are retriggered on new notes while 4-7 are continuous\n                if (ch.vibratotype < 4) {\n                    ch.vibratopos = 0;\n                }\n            }\n        }\n    }\n    function Envelope(points, type, sustain, loopstart, loopend) {\n        this.points = points;\n        this.type = type;\n        this.sustain = sustain;\n        this.loopstart = points[loopstart * 2];\n        this.loopend = points[loopend * 2];\n    }\n    Envelope.prototype.Get = function (ticks) {\n        // TODO: optimize follower with ptr\n        // or even do binary search here\n        var y0;\n        var env = this.points;\n        for (var i = 0; i < env.length; i += 2) {\n            y0 = env[i + 1];\n            if (ticks < env[i]) {\n                var x0 = env[i - 2];\n                y0 = env[i - 1];\n                var dx = env[i] - x0;\n                var dy = env[i + 1] - y0;\n                return y0 + (ticks - x0) * dy / dx;\n            }\n        }\n        return y0;\n    };\n    function EnvelopeFollower(env) {\n        this.env = env;\n        this.tick = 0;\n    }\n    EnvelopeFollower.prototype.Tick = function (release) {\n        var value = this.env.Get(this.tick);\n        // if we're sustaining a note, stop advancing the tick counter\n        if (!release && this.tick >= this.env.points[this.env.sustain * 2]) {\n            return this.env.points[this.env.sustain * 2 + 1];\n        }\n        this.tick++;\n        if (this.env.type & 4) { // envelope loop?\n            if (!release &&\n                this.tick >= this.env.loopend) {\n                this.tick -= this.env.loopend - this.env.loopstart;\n            }\n        }\n        return value;\n    };\n    function nextTick() {\n        player.cur_tick++;\n        var j, ch;\n        for (j = 0; j < player.xm.nchan; j++) {\n            ch = player.xm.channelinfo[j];\n            ch.periodoffset = 0;\n        }\n        if (player.cur_tick >= player.xm.tempo) {\n            player.cur_tick = 0;\n            nextRow();\n        }\n        for (j = 0; j < player.xm.nchan; j++) {\n            ch = player.xm.channelinfo[j];\n            var inst = ch.inst;\n            if (player.cur_tick !== 0) {\n                if (ch.voleffectfn)\n                    ch.voleffectfn(ch);\n                if (ch.effectfn)\n                    ch.effectfn(ch);\n            }\n            if (isNaN(ch.period)) {\n                console.log(prettify_notedata(player.xm.patterns[player.cur_pat][player.cur_row][j]), \"set channel\", j, \"period to NaN\");\n            }\n            if (inst === undefined)\n                continue;\n            if (ch.env_vol === undefined) {\n                console.log(prettify_notedata(player.xm.patterns[player.cur_pat][player.cur_row][j]), \"set channel\", j, \"env_vol to undefined, but note is playing\");\n                continue;\n            }\n            ch.volE = ch.env_vol.Tick(ch.release);\n            ch.panE = ch.env_pan.Tick(ch.release);\n            updateChannelPeriod(ch, ch.period + ch.periodoffset);\n        }\n    }\n    // This function gradually brings the channel back down to zero if it isn't\n    // already to avoid clicks and pops when samples end.\n    function MixSilenceIntoBuf(ch, start, end, dataL, dataR) {\n        var s = ch.filterstate[1];\n        if (isNaN(s)) {\n            console.log(\"NaN filterstate?\", ch.filterstate, ch.filter);\n            return;\n        }\n        for (var i = start; i < end; i++) {\n            if (Math.abs(s) < 1.526e-5) { // == 1/65536.0\n                s = 0;\n                break;\n            }\n            dataL[i] += s * ch.vL;\n            dataR[i] += s * ch.vR;\n            s *= popfilter_alpha;\n        }\n        ch.filterstate[1] = s;\n        ch.filterstate[2] = s;\n        if (isNaN(s)) {\n            console.log(\"NaN filterstate after adding silence?\", ch.filterstate, ch.filter, i);\n            return;\n        }\n        return 0;\n    }\n    function MixChannelIntoBuf(ch, start, end, dataL, dataR) {\n        var inst = ch.inst;\n        var instsamp = ch.samp;\n        var loop = false;\n        var looplen = 0, loopstart = 0;\n        // nothing on this channel, just filter the last dc offset back down to zero\n        if (instsamp == undefined || inst == undefined || ch.mute) {\n            return MixSilenceIntoBuf(ch, start, end, dataL, dataR);\n        }\n        var samp = instsamp.sampledata;\n        var sample_end = instsamp.len;\n        if ((instsamp.type & 3) == 1 && instsamp.looplen > 0) {\n            loop = true;\n            loopstart = instsamp.loop;\n            looplen = instsamp.looplen;\n            sample_end = loopstart + looplen;\n        }\n        var samplen = instsamp.len;\n        var volE = ch.volE / 64.0; // current volume envelope\n        var panE = 4 * (ch.panE - 32); // current panning envelope\n        var p = panE + ch.pan - 128; // final pan\n        var volL = player.xm.global_volume * volE * (128 - p) * ch.vol / (64 * 128 * 128);\n        var volR = player.xm.global_volume * volE * (128 + p) * ch.vol / (64 * 128 * 128);\n        if (volL < 0)\n            volL = 0;\n        if (volR < 0)\n            volR = 0;\n        if (volR === 0 && volL === 0)\n            return;\n        if (isNaN(volR) || isNaN(volL)) {\n            console.log(\"NaN volume!?\", ch.number, volL, volR, volE, panE, ch.vol);\n            return;\n        }\n        var k = ch.off;\n        var dk = ch.doff;\n        var Vrms = 0;\n        var f0 = ch.filter[0], f1 = ch.filter[1], f2 = ch.filter[2];\n        var fs0 = ch.filterstate[0], fs1 = ch.filterstate[1], fs2 = ch.filterstate[2];\n        // we also low-pass filter volume changes with a simple one-zero,\n        // one-pole filter to avoid pops and clicks when volume changes.\n        var vL = popfilter_alpha * ch.vL + (1 - popfilter_alpha) * (volL + ch.vLprev) * 0.5;\n        var vR = popfilter_alpha * ch.vR + (1 - popfilter_alpha) * (volR + ch.vRprev) * 0.5;\n        var pf_8 = Math.pow(popfilter_alpha, 8);\n        ch.vLprev = volL;\n        ch.vRprev = volR;\n        // we can mix up to this many bytes before running into a sample end/loop\n        var i = start;\n        var failsafe = 100;\n        while (i < end) {\n            if (failsafe-- === 0) {\n                console.log(\"failsafe in mixing loop! channel\", ch.number, k, sample_end, loopstart, looplen, dk);\n                break;\n            }\n            if (k >= sample_end) { // TODO: implement pingpong looping\n                if (loop) {\n                    k = loopstart + (k - loopstart) % looplen;\n                }\n                else {\n                    // kill sample\n                    ch.inst = undefined;\n                    // fill rest of buf with filtered dc offset using loop above\n                    return Vrms + MixSilenceIntoBuf(ch, i, end, dataL, dataR);\n                }\n            }\n            var next_event = Math.max(1, Math.min(end, i + (sample_end - k) / dk));\n            // this is the inner loop of the player\n            // unrolled 8x\n            var s, y;\n            for (; i + 7 < next_event; i += 8) {\n                s = samp[k | 0];\n                y = f0 * (s + fs0) + f1 * fs1 + f2 * fs2;\n                fs2 = fs1;\n                fs1 = y;\n                fs0 = s;\n                k += dk;\n                dataL[i] += vL * y;\n                dataR[i] += vR * y;\n                Vrms += (vL + vR) * y * y;\n                s = samp[k | 0];\n                y = f0 * (s + fs0) + f1 * fs1 + f2 * fs2;\n                fs2 = fs1;\n                fs1 = y;\n                fs0 = s;\n                k += dk;\n                dataL[i + 1] += vL * y;\n                dataR[i + 1] += vR * y;\n                Vrms += (vL + vR) * y * y;\n                s = samp[k | 0];\n                y = f0 * (s + fs0) + f1 * fs1 + f2 * fs2;\n                fs2 = fs1;\n                fs1 = y;\n                fs0 = s;\n                k += dk;\n                dataL[i + 2] += vL * y;\n                dataR[i + 2] += vR * y;\n                Vrms += (vL + vR) * y * y;\n                s = samp[k | 0];\n                y = f0 * (s + fs0) + f1 * fs1 + f2 * fs2;\n                fs2 = fs1;\n                fs1 = y;\n                fs0 = s;\n                k += dk;\n                dataL[i + 3] += vL * y;\n                dataR[i + 3] += vR * y;\n                Vrms += (vL + vR) * y * y;\n                s = samp[k | 0];\n                y = f0 * (s + fs0) + f1 * fs1 + f2 * fs2;\n                fs2 = fs1;\n                fs1 = y;\n                fs0 = s;\n                k += dk;\n                dataL[i + 4] += vL * y;\n                dataR[i + 4] += vR * y;\n                Vrms += (vL + vR) * y * y;\n                s = samp[k | 0];\n                y = f0 * (s + fs0) + f1 * fs1 + f2 * fs2;\n                fs2 = fs1;\n                fs1 = y;\n                fs0 = s;\n                k += dk;\n                dataL[i + 5] += vL * y;\n                dataR[i + 5] += vR * y;\n                Vrms += (vL + vR) * y * y;\n                s = samp[k | 0];\n                y = f0 * (s + fs0) + f1 * fs1 + f2 * fs2;\n                fs2 = fs1;\n                fs1 = y;\n                fs0 = s;\n                k += dk;\n                dataL[i + 6] += vL * y;\n                dataR[i + 6] += vR * y;\n                Vrms += (vL + vR) * y * y;\n                s = samp[k | 0];\n                y = f0 * (s + fs0) + f1 * fs1 + f2 * fs2;\n                fs2 = fs1;\n                fs1 = y;\n                fs0 = s;\n                k += dk;\n                dataL[i + 7] += vL * y;\n                dataR[i + 7] += vR * y;\n                Vrms += (vL + vR) * y * y;\n                vL = pf_8 * vL + (1 - pf_8) * volL;\n                vR = pf_8 * vR + (1 - pf_8) * volR;\n            }\n            for (; i < next_event; i++) {\n                s = samp[k | 0];\n                // we low-pass filter here since we are resampling some arbitrary\n                // frequency to f_smp; this is an anti-aliasing filter and is\n                // implemented as an IIR butterworth filter (usually we'd use an FIR\n                // brick wall filter, but this is much simpler computationally and\n                // sounds fine)\n                y = f0 * (s + fs0) + f1 * fs1 + f2 * fs2;\n                fs2 = fs1;\n                fs1 = y;\n                fs0 = s;\n                dataL[i] += vL * y;\n                dataR[i] += vR * y;\n                Vrms += (vL + vR) * y * y;\n                k += dk;\n            }\n        }\n        ch.off = k;\n        ch.filterstate[0] = fs0;\n        ch.filterstate[1] = fs1;\n        ch.filterstate[2] = fs2;\n        ch.vL = vL;\n        ch.vR = vR;\n        return Vrms * 0.5;\n    }\n    function audio_cb(e) {\n        f_smp = player.audioctx.sampleRate;\n        var time_sound_started;\n        var buflen = e.outputBuffer.length;\n        var dataL = e.outputBuffer.getChannelData(0);\n        var dataR = e.outputBuffer.getChannelData(1);\n        var i, j, k;\n        for (i = 0; i < buflen; i++) {\n            dataL[i] = 0;\n            dataR[i] = 0;\n        }\n        var offset = 0;\n        var ticklen = 0 | (f_smp * 2.5 / player.xm.bpm);\n        var scopewidth = XMView.scope_width;\n        while (buflen > 0) {\n            if (player.cur_pat == -1 || player.cur_ticksamp >= ticklen) {\n                nextTick(f_smp);\n                player.cur_ticksamp -= ticklen;\n            }\n            var tickduration = Math.min(buflen, ticklen - player.cur_ticksamp);\n            var VU = new Float32Array(player.xm.nchan);\n            var scopes = undefined;\n            for (j = 0; j < player.xm.nchan; j++) {\n                var scope;\n                if (tickduration >= 4 * scopewidth) {\n                    scope = new Float32Array(scopewidth);\n                    for (k = 0; k < scopewidth; k++) {\n                        scope[k] = -dataL[offset + k * 4] - dataR[offset + k * 4];\n                    }\n                }\n                VU[j] = MixChannelIntoBuf(player.xm.channelinfo[j], offset, offset + tickduration, dataL, dataR) /\n                    tickduration;\n                if (tickduration >= 4 * scopewidth) {\n                    for (k = 0; k < scopewidth; k++) {\n                        scope[k] += dataL[offset + k * 4] + dataR[offset + k * 4];\n                    }\n                    if (scopes === undefined)\n                        scopes = [];\n                    scopes.push(scope);\n                }\n            }\n            if (XMView.pushEvent) {\n                XMView.pushEvent({\n                    t: e.playbackTime + (0.0 + offset) / f_smp,\n                    vu: VU,\n                    scopes: scopes,\n                    songpos: player.cur_songpos,\n                    pat: player.cur_pat,\n                    row: player.cur_row\n                });\n            }\n            offset += tickduration;\n            player.cur_ticksamp += tickduration;\n            buflen -= tickduration;\n        }\n    }\n    function ConvertSample(array, bits) {\n        var len = array.length;\n        var acc = 0;\n        var samp, b, k;\n        if (bits === 0) { // 8 bit sample\n            samp = new Float32Array(len);\n            for (k = 0; k < len; k++) {\n                acc += array[k];\n                b = acc & 255;\n                if (b & 128)\n                    b = b - 256;\n                samp[k] = b / 128.0;\n            }\n            return samp;\n        }\n        else {\n            len /= 2;\n            samp = new Float32Array(len);\n            for (k = 0; k < len; k++) {\n                b = array[k * 2] + (array[k * 2 + 1] << 8);\n                if (b & 32768)\n                    b = b - 65536;\n                acc = Math.max(-1, Math.min(1, acc + b / 32768.0));\n                samp[k] = acc;\n            }\n            return samp;\n        }\n    }\n    // optimization: unroll short sample loops so we can run our inner mixing loop\n    // uninterrupted for as long as possible; this also handles pingpong loops.\n    function UnrollSampleLoop(samp) {\n        var nloops = ((2048 + samp.looplen - 1) / samp.looplen) | 0;\n        var pingpong = samp.type & 2;\n        if (pingpong) {\n            // make sure we have an even number of loops if we are pingponging\n            nloops = (nloops + 1) & (~1);\n        }\n        var samplesiz = samp.loop + nloops * samp.looplen;\n        var data = new Float32Array(samplesiz);\n        for (var i = 0; i < samp.loop; i++) {\n            data[i] = samp.sampledata[i];\n        }\n        for (var j = 0; j < nloops; j++) {\n            var k;\n            if ((j & 1) && pingpong) {\n                for (k = samp.looplen - 1; k >= 0; k--) {\n                    data[i++] = samp.sampledata[samp.loop + k];\n                }\n            }\n            else {\n                for (k = 0; k < samp.looplen; k++) {\n                    data[i++] = samp.sampledata[samp.loop + k];\n                }\n            }\n        }\n        console.log(\"unrolled sample loop; looplen\", samp.looplen, \"x\", nloops, \" = \", samplesiz);\n        samp.sampledata = data;\n        samp.looplen = nloops * samp.looplen;\n        samp.type = 1;\n    }\n    function load(arrayBuf) {\n        var dv = new DataView(arrayBuf);\n        player.xm = {};\n        player.xm.songname = getstring(dv, 17, 20);\n        var hlen = dv.getUint32(0x3c, true) + 0x3c;\n        var songlen = dv.getUint16(0x40, true);\n        player.xm.song_looppos = dv.getUint16(0x42, true);\n        player.xm.nchan = dv.getUint16(0x44, true);\n        var npat = dv.getUint16(0x46, true);\n        var ninst = dv.getUint16(0x48, true);\n        player.xm.flags = dv.getUint16(0x4a, true);\n        player.xm.tempo = dv.getUint16(0x4c, true);\n        player.xm.bpm = dv.getUint16(0x4e, true);\n        player.xm.channelinfo = [];\n        player.xm.global_volume = player.max_global_volume;\n        var i, j, k;\n        for (i = 0; i < player.xm.nchan; i++) {\n            player.xm.channelinfo.push({\n                number: i,\n                filterstate: new Float32Array(3),\n                vol: 0,\n                pan: 128,\n                period: 1920 - 48 * 16,\n                vL: 0, vR: 0,\n                vLprev: 0, vRprev: 0,\n                mute: 0,\n                volE: 0, panE: 0,\n                retrig: 0,\n                vibratopos: 0,\n                vibratodepth: 1,\n                vibratospeed: 1,\n                vibratotype: 0,\n            });\n        }\n        console.log(\"header len \" + hlen);\n        console.log(\"songlen %d, %d channels, %d patterns, %d instruments\", songlen, player.xm.nchan, npat, ninst);\n        console.log(\"loop @%d\", player.xm.song_looppos);\n        console.log(\"flags=%d tempo %d bpm %d\", player.xm.flags, player.xm.tempo, player.xm.bpm);\n        player.xm.songpats = [];\n        for (i = 0; i < songlen; i++) {\n            player.xm.songpats.push(dv.getUint8(0x50 + i));\n        }\n        console.log(\"song patterns: \", player.xm.songpats);\n        var idx = hlen;\n        player.xm.patterns = [];\n        for (i = 0; i < npat; i++) {\n            var pattern = [];\n            var patheaderlen = dv.getUint32(idx, true);\n            var patrows = dv.getUint16(idx + 5, true);\n            var patsize = dv.getUint16(idx + 7, true);\n            console.log(\"pattern %d: %d bytes, %d rows\", i, patsize, patrows);\n            idx += 9;\n            for (j = 0; patsize > 0 && j < patrows; j++) {\n                row = [];\n                for (k = 0; k < player.xm.nchan; k++) {\n                    var byte0 = dv.getUint8(idx);\n                    idx++;\n                    var note = -1, inst = -1, vol = -1, efftype = 0, effparam = 0;\n                    if (byte0 & 0x80) {\n                        if (byte0 & 0x01) {\n                            note = dv.getUint8(idx) - 1;\n                            idx++;\n                        }\n                        if (byte0 & 0x02) {\n                            inst = dv.getUint8(idx);\n                            idx++;\n                        }\n                        if (byte0 & 0x04) {\n                            vol = dv.getUint8(idx);\n                            idx++;\n                        }\n                        if (byte0 & 0x08) {\n                            efftype = dv.getUint8(idx);\n                            idx++;\n                        }\n                        if (byte0 & 0x10) {\n                            effparam = dv.getUint8(idx);\n                            idx++;\n                        }\n                    }\n                    else {\n                        // byte0 is note from 1..96 or 0 for nothing or 97 for release\n                        // so we subtract 1 so that C-0 is stored as 0\n                        note = byte0 - 1;\n                        inst = dv.getUint8(idx);\n                        idx++;\n                        vol = dv.getUint8(idx);\n                        idx++;\n                        efftype = dv.getUint8(idx);\n                        idx++;\n                        effparam = dv.getUint8(idx);\n                        idx++;\n                    }\n                    var notedata = [note, inst, vol, efftype, effparam];\n                    row.push(notedata);\n                }\n                pattern.push(row);\n            }\n            player.xm.patterns.push(pattern);\n        }\n        player.xm.instruments = [];\n        // now load instruments\n        for (i = 0; i < ninst; i++) {\n            var hdrsiz = dv.getUint32(idx, true);\n            var instname = getstring(dv, idx + 0x4, 22);\n            var nsamp = dv.getUint16(idx + 0x1b, true);\n            var inst = {\n                'name': instname,\n                'number': i,\n            };\n            if (nsamp > 0) {\n                var samplemap = new Uint8Array(arrayBuf, idx + 33, 96);\n                var env_nvol = dv.getUint8(idx + 225);\n                var env_vol_type = dv.getUint8(idx + 233);\n                var env_vol_sustain = dv.getUint8(idx + 227);\n                var env_vol_loop_start = dv.getUint8(idx + 228);\n                var env_vol_loop_end = dv.getUint8(idx + 229);\n                var env_npan = dv.getUint8(idx + 226);\n                var env_pan_type = dv.getUint8(idx + 234);\n                var env_pan_sustain = dv.getUint8(idx + 230);\n                var env_pan_loop_start = dv.getUint8(idx + 231);\n                var env_pan_loop_end = dv.getUint8(idx + 232);\n                var vol_fadeout = dv.getUint16(idx + 239, true);\n                var env_vol = [];\n                for (j = 0; j < env_nvol * 2; j++) {\n                    env_vol.push(dv.getUint16(idx + 129 + j * 2, true));\n                }\n                var env_pan = [];\n                for (j = 0; j < env_npan * 2; j++) {\n                    env_pan.push(dv.getUint16(idx + 177 + j * 2, true));\n                }\n                // FIXME: ignoring keymaps for now and assuming 1 sample / instrument\n                // var keymap = getarray(dv, idx+0x21);\n                var samphdrsiz = dv.getUint32(idx + 0x1d, true);\n                console.log(\"hdrsiz %d; instrument %s: '%s' %d samples, samphdrsiz %d\", hdrsiz, (i + 1).toString(16), instname, nsamp, samphdrsiz);\n                idx += hdrsiz;\n                var totalsamples = 0;\n                var samps = [];\n                for (j = 0; j < nsamp; j++) {\n                    var samplen = dv.getUint32(idx, true);\n                    var samploop = dv.getUint32(idx + 4, true);\n                    var samplooplen = dv.getUint32(idx + 8, true);\n                    var sampvol = dv.getUint8(idx + 12);\n                    var sampfinetune = dv.getInt8(idx + 13);\n                    var samptype = dv.getUint8(idx + 14);\n                    var samppan = dv.getUint8(idx + 15);\n                    var sampnote = dv.getInt8(idx + 16);\n                    var sampname = getstring(dv, idx + 18, 22);\n                    var sampleoffset = totalsamples;\n                    if (samplooplen === 0) {\n                        samptype &= ~3;\n                    }\n                    console.log(\"sample %d: len %d name '%s' loop %d/%d vol %d offset %s\", j, samplen, sampname, samploop, samplooplen, sampvol, sampleoffset.toString(16));\n                    console.log(\"           type %d note %s(%d) finetune %d pan %d\", samptype, prettify_note(sampnote + 12 * 4), sampnote, sampfinetune, samppan);\n                    console.log(\"           vol env\", env_vol, env_vol_sustain, env_vol_loop_start, env_vol_loop_end, \"type\", env_vol_type, \"fadeout\", vol_fadeout);\n                    console.log(\"           pan env\", env_pan, env_pan_sustain, env_pan_loop_start, env_pan_loop_end, \"type\", env_pan_type);\n                    var samp = {\n                        'len': samplen, 'loop': samploop,\n                        'looplen': samplooplen, 'note': sampnote, 'fine': sampfinetune,\n                        'pan': samppan, 'type': samptype, 'vol': sampvol,\n                        'fileoffset': sampleoffset\n                    };\n                    // length / pointers are all specified in bytes; fixup for 16-bit samples\n                    samps.push(samp);\n                    idx += samphdrsiz;\n                    totalsamples += samplen;\n                }\n                for (j = 0; j < nsamp; j++) {\n                    var samp = samps[j];\n                    samp.sampledata = ConvertSample(new Uint8Array(arrayBuf, idx + samp.fileoffset, samp.len), samp.type & 16);\n                    if (samp.type & 16) {\n                        samp.len /= 2;\n                        samp.loop /= 2;\n                        samp.looplen /= 2;\n                    }\n                    // unroll short loops and any pingpong loops\n                    if ((samp.type & 3) && (samp.looplen < 2048 || (samp.type & 2))) {\n                        UnrollSampleLoop(samp);\n                    }\n                }\n                idx += totalsamples;\n                inst.samplemap = samplemap;\n                inst.samples = samps;\n                if (env_vol_type) {\n                    // insert an automatic fadeout to 0 at the end of the envelope\n                    var env_end_tick = env_vol[env_vol.length - 2];\n                    if (!(env_vol_type & 2)) { // if there's no sustain point, create one\n                        env_vol_sustain = env_vol.length / 2;\n                    }\n                    if (vol_fadeout > 0) {\n                        var fadeout_ticks = 65536.0 / vol_fadeout;\n                        env_vol.push(env_end_tick + fadeout_ticks);\n                        env_vol.push(0);\n                    }\n                    inst.env_vol = new Envelope(env_vol, env_vol_type, env_vol_sustain, env_vol_loop_start, env_vol_loop_end);\n                }\n                else {\n                    // no envelope, then just make a default full-volume envelope.\n                    // i thought this would use fadeout, but apparently it doesn't.\n                    inst.env_vol = new Envelope([0, 64, 1, 0], 2, 0, 0, 0);\n                }\n                if (env_pan_type) {\n                    if (!(env_pan_type & 2)) { // if there's no sustain point, create one\n                        env_pan_sustain = env_pan.length / 2;\n                    }\n                    inst.env_pan = new Envelope(env_pan, env_pan_type, env_pan_sustain, env_pan_loop_start, env_pan_loop_end);\n                }\n                else {\n                    // create a default empty envelope\n                    inst.env_pan = new Envelope([0, 32], 0, 0, 0, 0);\n                }\n            }\n            else {\n                idx += hdrsiz;\n                console.log(\"empty instrument\", i, hdrsiz, idx);\n            }\n            player.xm.instruments.push(inst);\n        }\n        console.log(\"loaded \\\"\" + player.xm.songname + \"\\\"\");\n        return true;\n    }\n    var jsNode, gainNode;\n    function init() {\n        if (!player.audioctx) {\n            var audioContext = window.AudioContext || window.webkitAudioContext;\n            player.audioctx = new audioContext();\n            gainNode = player.audioctx.createGain();\n            gainNode.gain.value = 0.1; // master volume\n        }\n        if (player.audioctx.createScriptProcessor === undefined) {\n            jsNode = player.audioctx.createJavaScriptNode(16384, 0, 2);\n        }\n        else {\n            jsNode = player.audioctx.createScriptProcessor(16384, 0, 2);\n        }\n        jsNode.onaudioprocess = audio_cb;\n        gainNode.connect(player.audioctx.destination);\n    }\n    player.playing = false;\n    function play() {\n        if (!player.playing) {\n            // put paused events back into action, if any\n            if (XMView.resume)\n                XMView.resume();\n            // start playing\n            jsNode.connect(gainNode);\n            // hack to get iOS to play anything\n            var temp_osc = player.audioctx.createOscillator();\n            temp_osc.connect(player.audioctx.destination);\n            !!temp_osc.start ? temp_osc.start(0) : temp_osc.noteOn(0);\n            !!temp_osc.stop ? temp_osc.stop(0) : temp_osc.noteOff(0);\n            temp_osc.disconnect();\n        }\n        player.playing = true;\n    }\n    function pause() {\n        if (player.playing) {\n            jsNode.disconnect(gainNode);\n            if (XMView.pause)\n                XMView.pause();\n        }\n        player.playing = false;\n    }\n    function stop() {\n        if (player.playing) {\n            jsNode.disconnect(gainNode);\n            player.playing = false;\n        }\n        player.cur_pat = -1;\n        player.cur_row = 64;\n        player.cur_songpos = -1;\n        player.cur_ticksamp = 0;\n        player.xm.global_volume = player.max_global_volume;\n        if (XMView.stop)\n            XMView.stop();\n        init();\n    }\n})(window);\n\n\n//# sourceURL=webpack:///./node_modules/jsxm/xm.js?");

/***/ }),

/***/ "./node_modules/jsxm/xmeffects.js":
/*!****************************************!*\
  !*** ./node_modules/jsxm/xmeffects.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function (window) {\n    if (!window.XMPlayer) {\n        window.XMPlayer = {};\n    }\n    var player = window.XMPlayer;\n    function eff_t1_0(ch) {\n        if (ch.effectdata !== 0 && ch.inst !== undefined) {\n            var arpeggio = [0, ch.effectdata >> 4, ch.effectdata & 15];\n            var note = ch.note + arpeggio[player.cur_tick % 3];\n            ch.period = player.periodForNote(ch, note);\n        }\n    }\n    function eff_t0_1(ch, data) {\n        if (data !== 0) {\n            ch.slideupspeed = data;\n        }\n    }\n    function eff_t1_1(ch) {\n        if (ch.slideupspeed !== undefined) {\n            // is this limited? it appears not\n            ch.period -= ch.slideupspeed;\n        }\n    }\n    function eff_t0_2(ch, data) {\n        if (data !== 0) {\n            ch.slidedownspeed = data;\n        }\n    }\n    function eff_t1_2(ch) {\n        if (ch.slidedownspeed !== undefined) {\n            // 1728 is the period for C-1\n            ch.period = Math.min(1728, ch.period + ch.slidedownspeed);\n        }\n    }\n    function eff_t0_3(ch, data) {\n        if (data !== 0) {\n            ch.portaspeed = data;\n        }\n    }\n    function eff_t1_3(ch) {\n        if (ch.periodtarget !== undefined && ch.portaspeed !== undefined) {\n            if (ch.period > ch.periodtarget) {\n                ch.period = Math.max(ch.periodtarget, ch.period - ch.portaspeed);\n            }\n            else {\n                ch.period = Math.min(ch.periodtarget, ch.period + ch.portaspeed);\n            }\n        }\n    }\n    function eff_t0_4(ch, data) {\n        if (data & 0x0f) {\n            ch.vibratodepth = (data & 0x0f) * 2;\n        }\n        if (data >> 4) {\n            ch.vibratospeed = data >> 4;\n        }\n        eff_t1_4(ch);\n    }\n    function eff_t1_4(ch) {\n        ch.periodoffset = getVibratoDelta(ch.vibratotype, ch.vibratopos) * ch.vibratodepth;\n        if (isNaN(ch.periodoffset)) {\n            console.log(\"vibrato periodoffset NaN?\", ch.vibratopos, ch.vibratospeed, ch.vibratodepth);\n            ch.periodoffset = 0;\n        }\n        // only updates on non-first ticks\n        if (player.cur_tick > 0) {\n            ch.vibratopos += ch.vibratospeed;\n            ch.vibratopos &= 63;\n        }\n    }\n    function getVibratoDelta(type, x) {\n        var delta = 0;\n        switch (type & 0x03) {\n            case 1: // sawtooth (ramp-down)\n                delta = ((1 + x * 2 / 64) % 2) - 1;\n                break;\n            case 2: // square\n            case 3: // random (in FT2 these two are the same)\n                delta = x < 32 ? 1 : -1;\n                break;\n            case 0:\n            default: // sine\n                delta = Math.sin(x * Math.PI / 32);\n                break;\n        }\n        return delta;\n    }\n    function eff_t1_5(ch) {\n        eff_t1_a(ch);\n        eff_t1_3(ch);\n    }\n    function eff_t1_6(ch) {\n        eff_t1_a(ch);\n        eff_t1_4(ch);\n    }\n    function eff_t0_8(ch, data) {\n        ch.pan = data;\n    }\n    function eff_t0_9(ch, data) {\n        ch.off = data * 256;\n    }\n    function eff_t0_a(ch, data) {\n        if (data) {\n            ch.volumeslide = -(data & 0x0f) + (data >> 4);\n        }\n    }\n    function eff_t1_a(ch) {\n        if (ch.volumeslide !== undefined) {\n            ch.vol = Math.max(0, Math.min(64, ch.vol + ch.volumeslide));\n        }\n    }\n    function eff_t0_b(ch, data) {\n        if (data < player.xm.songpats.length) {\n            player.cur_songpos = data - 1;\n            player.cur_pat = -1;\n            player.cur_row = -1;\n        }\n    }\n    function eff_t0_c(ch, data) {\n        ch.vol = Math.min(64, data);\n    }\n    function eff_t0_d(ch, data) {\n        player.cur_songpos++;\n        if (player.cur_songpos >= player.xm.songpats.length)\n            player.cur_songpos = player.xm.song_looppos;\n        player.cur_pat = player.xm.songpats[player.cur_songpos];\n        player.next_row = (data >> 4) * 10 + (data & 0x0f);\n    }\n    function eff_t0_e(ch, data) {\n        var eff = data >> 4;\n        data = data & 0x0f;\n        switch (eff) {\n            case 1: // fine porta up\n                ch.period -= data;\n                break;\n            case 2: // fine porta down\n                ch.period += data;\n                break;\n            case 4: // set vibrato waveform\n                ch.vibratotype = data & 0x07;\n                break;\n            case 5: // finetune\n                ch.fine = (data << 4) + data - 128;\n                break;\n            case 6: // pattern loop\n                if (data == 0) {\n                    ch.loopstart = player.cur_row;\n                }\n                else {\n                    if (typeof ch.loopend === \"undefined\") {\n                        ch.loopend = player.cur_row;\n                        ch.loopremaining = data;\n                    }\n                    if (ch.loopremaining !== 0) {\n                        ch.loopremaining--;\n                        player.next_row = ch.loopstart || 0;\n                    }\n                    else {\n                        delete ch.loopend;\n                        delete ch.loopstart;\n                    }\n                }\n                break;\n            case 8: // panning\n                ch.pan = data * 0x11;\n                break;\n            case 0x0a: // fine vol slide up (with memory)\n                if (data === 0 && ch.finevolup !== undefined)\n                    data = ch.finevolup;\n                ch.vol = Math.min(64, ch.vol + data);\n                ch.finevolup = data;\n                break;\n            case 0x0b: // fine vol slide down\n                if (data === 0 && ch.finevoldown !== undefined)\n                    data = ch.finevoldown;\n                ch.vol = Math.max(0, ch.vol - data);\n                ch.finevoldown = data;\n                break;\n            case 0x0c: // note cut handled in eff_t1_e\n                break;\n            default:\n                console.log(\"unimplemented extended effect E\", ch.effectdata.toString(16));\n                break;\n        }\n    }\n    function eff_t1_e(ch) {\n        switch (ch.effectdata >> 4) {\n            case 0x0c:\n                if (player.cur_tick == (ch.effectdata & 0x0f)) {\n                    ch.vol = 0;\n                }\n                break;\n        }\n    }\n    function eff_t0_f(ch, data) {\n        if (data === 0) {\n            console.log(\"tempo 0?\");\n            return;\n        }\n        else if (data < 0x20) {\n            player.xm.tempo = data;\n        }\n        else {\n            player.xm.bpm = data;\n        }\n    }\n    function eff_t0_g(ch, data) {\n        if (data <= 0x40) {\n            // volume gets multiplied by 2 to match\n            // the initial max global volume of 128\n            player.xm.global_volume = Math.max(0, data * 2);\n        }\n        else {\n            player.xm.global_volume = player.max_global_volume;\n        }\n    }\n    function eff_t0_h(ch, data) {\n        if (data) {\n            // same as Axy but multiplied by 2\n            player.xm.global_volumeslide = (-(data & 0x0f) + (data >> 4)) * 2;\n        }\n    }\n    function eff_t1_h(ch) {\n        if (player.xm.global_volumeslide !== undefined) {\n            player.xm.global_volume = Math.max(0, Math.min(player.max_global_volume, player.xm.global_volume + player.xm.global_volumeslide));\n        }\n    }\n    function eff_t0_r(ch, data) {\n        if (data & 0x0f)\n            ch.retrig = (ch.retrig & 0xf0) + (data & 0x0f);\n        if (data & 0xf0)\n            ch.retrig = (ch.retrig & 0x0f) + (data & 0xf0);\n        // retrigger volume table\n        switch (ch.retrig >> 4) {\n            case 1:\n                ch.vol -= 1;\n                break;\n            case 2:\n                ch.vol -= 2;\n                break;\n            case 3:\n                ch.vol -= 4;\n                break;\n            case 4:\n                ch.vol -= 8;\n                break;\n            case 5:\n                ch.vol -= 16;\n                break;\n            case 6:\n                ch.vol *= 2;\n                ch.vol /= 3;\n                break;\n            case 7:\n                ch.vol /= 2;\n                break;\n            case 9:\n                ch.vol += 1;\n                break;\n            case 0x0a:\n                ch.vol += 2;\n                break;\n            case 0x0b:\n                ch.vol += 4;\n                break;\n            case 0x0c:\n                ch.vol += 8;\n                break;\n            case 0x0d:\n                ch.vol += 16;\n                break;\n            case 0x0e:\n                ch.vol *= 3;\n                ch.vol /= 2;\n                break;\n            case 0x0f:\n                ch.vol *= 2;\n                break;\n        }\n        ch.vol = Math.min(64, Math.max(0, ch.vol));\n    }\n    function eff_t1_r(ch) {\n        if (player.cur_tick % (ch.retrig & 0x0f) === 0) {\n            ch.off = 0;\n        }\n    }\n    function eff_unimplemented() { }\n    function eff_unimplemented_t0(ch, data) {\n        console.log(\"unimplemented effect\", player.prettify_effect(ch.effect, data));\n    }\n    player.effects_t0 = [\n        eff_t1_0,\n        eff_t0_1,\n        eff_t0_2,\n        eff_t0_3,\n        eff_t0_4,\n        eff_t0_a,\n        eff_t0_a,\n        eff_unimplemented_t0,\n        eff_t0_8,\n        eff_t0_9,\n        eff_t0_a,\n        eff_t0_b,\n        eff_t0_c,\n        eff_t0_d,\n        eff_t0_e,\n        eff_t0_f,\n        eff_t0_g,\n        eff_t0_h,\n        eff_unimplemented_t0,\n        eff_unimplemented_t0,\n        eff_unimplemented_t0,\n        eff_unimplemented_t0,\n        eff_unimplemented_t0,\n        eff_unimplemented_t0,\n        eff_unimplemented_t0,\n        eff_unimplemented_t0,\n        eff_unimplemented_t0,\n        eff_t0_r,\n        eff_unimplemented_t0,\n        eff_unimplemented_t0,\n        eff_unimplemented_t0,\n        eff_unimplemented_t0,\n        eff_unimplemented_t0,\n        eff_unimplemented_t0,\n        eff_unimplemented_t0,\n        eff_unimplemented_t0,\n    ];\n    player.effects_t1 = [\n        eff_t1_0,\n        eff_t1_1,\n        eff_t1_2,\n        eff_t1_3,\n        eff_t1_4,\n        eff_t1_5,\n        eff_t1_6,\n        eff_unimplemented,\n        null,\n        null,\n        eff_t1_a,\n        null,\n        null,\n        null,\n        eff_t1_e,\n        null,\n        null,\n        eff_t1_h,\n        eff_unimplemented,\n        eff_unimplemented,\n        eff_unimplemented,\n        eff_unimplemented,\n        eff_unimplemented,\n        eff_unimplemented,\n        eff_unimplemented,\n        eff_unimplemented,\n        eff_unimplemented,\n        eff_t1_r,\n        eff_unimplemented,\n        eff_unimplemented,\n        eff_unimplemented,\n        eff_unimplemented,\n        eff_unimplemented,\n        eff_unimplemented,\n        eff_unimplemented,\n        eff_unimplemented // z\n    ];\n})(window);\n\n\n//# sourceURL=webpack:///./node_modules/jsxm/xmeffects.js?");

/***/ }),

/***/ "./src/Gamepad.ts":
/*!************************!*\
  !*** ./src/Gamepad.ts ***!
  \************************/
/*! exports provided: Gamepad2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Gamepad2\", function() { return Gamepad2; });\nclass Gamepad2 {\n    constructor() {\n        window.addEventListener('gamepadconnected', (e) => {\n            console.log('Gamepad connected at index %d: %s. %d buttons, %d axes.', e.gamepad.index, e.gamepad.id, e.gamepad.buttons.length, e.gamepad.axes.length);\n            this.gamepad = e.gamepad;\n        });\n    }\n    isButtonPressed(index) {\n        if (this.gamepad) {\n            return this.gamepad.buttons[index].pressed;\n        }\n        return false;\n    }\n    isLeft(axis, value) {\n        if (this.gamepad) {\n            return this.gamepad.axes[axis] === value;\n        }\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/Gamepad.ts?");

/***/ }),

/***/ "./src/OptionList.ts":
/*!***************************!*\
  !*** ./src/OptionList.ts ***!
  \***************************/
/*! exports provided: OptionList */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OptionList\", function() { return OptionList; });\n/**\n * OptionList\n *\n * @export\n * @class OptionList\n * @template T\n */\nclass OptionList {\n    constructor(options, defaultIndex = 0, rotate = false) {\n        this.rotate = rotate;\n        this.options = options;\n        this.index = defaultIndex;\n    }\n    triggerCallback() {\n        this.callback(this.options[this.index]);\n    }\n    addChangeListener(callback) {\n        this.callback = callback;\n    }\n    getOption() {\n        return this.options[this.index];\n    }\n    getOptions() {\n        return this.options;\n    }\n    getIndex() {\n        return this.index;\n    }\n    next() {\n        const previousIndex = this.index;\n        if (this.rotate) {\n            this.index = (this.index + 1) % this.options.length;\n        }\n        else {\n            this.index = Math.min(this.index + 1, this.options.length - 1);\n        }\n        if (this.callback && this.index !== previousIndex) {\n            this.callback(this.options[this.index]);\n        }\n    }\n    previous() {\n        const previousIndex = this.index;\n        if (this.rotate) {\n            this.index = (this.index - 1 + this.options.length) % this.options.length;\n        }\n        else {\n            this.index = Math.max(this.index - 1, 0);\n        }\n        if (this.callback && this.index !== previousIndex) {\n            this.callback(this.options[this.index]);\n        }\n    }\n}\n\n\n//# sourceURL=webpack:///./src/OptionList.ts?");

/***/ }),

/***/ "./src/Playfield.ts":
/*!**************************!*\
  !*** ./src/Playfield.ts ***!
  \**************************/
/*! exports provided: Playfield */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Playfield\", function() { return Playfield; });\n/**\n * The playfield class\n */\nclass Playfield {\n    constructor(width, height, image) {\n        this.width = width;\n        this.height = height;\n        this.image = image;\n        this.width = width;\n        this.height = height;\n        this.field = new Array(width * height);\n        this.field.fill(0);\n    }\n    isFullRow(row) {\n        let fullRow = true;\n        for (let x = 0; x < this.width; x++) {\n            if (this.field[x + row * this.width] === 0) {\n                fullRow = false;\n                break;\n            }\n        }\n        return fullRow;\n    }\n    removeFullRows() {\n        let removal = false;\n        for (let y = 0; y < this.height; y++) {\n            if (this.isFullRow(y)) {\n                this.field.splice(y * 10, 10);\n                this.field.unshift(...[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n                removal = true;\n            }\n        }\n        return removal;\n    }\n    getNumberOfFullRows() {\n        let count = 0;\n        for (let y = 0; y < this.height; y++) {\n            if (this.isFullRow(y)) {\n                count++;\n            }\n        }\n        return count;\n    }\n    getfFullRows() {\n        const rows = new Array();\n        for (let y = 0; y < this.height; y++) {\n            if (this.isFullRow(y)) {\n                rows.push(y);\n            }\n        }\n        return rows;\n    }\n    hasFullRows() {\n        for (let y = 0; y < this.height; y++) {\n            if (this.isFullRow(y)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    draw(context) {\n        context.translate(96, 40);\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                const num = this.field[x + y * this.width];\n                if (num !== 0) {\n                    this.drawSprite(context, x, y, num);\n                }\n            }\n        }\n    }\n    drawSprite(context, x, y, sprite) {\n        context.drawImage(this.image, 8 * sprite, 0, 8, 8, x * 8, y * 8, 8, 8);\n    }\n    collides(shape) {\n        const tiles = shape.getTiles();\n        for (let i = 0; i < tiles.length; i++) {\n            const tile = tiles[i];\n            if (this.isSet(tile.x, tile.y)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    setBlocks(shape) {\n        const tiles = shape.getTiles();\n        for (let i = 0; i < tiles.length; i++) {\n            const tile = tiles[i];\n            this.set(tile.x, tile.y, shape.spriteId);\n        }\n        return false;\n    }\n    isSet(x, y) {\n        if (x < 0 || y < 0 || x >= this.width || y >= this.height) {\n            return true;\n        }\n        return this.field[x + y * this.width] !== 0;\n    }\n    set(x, y, tileId = 1) {\n        this.field[x + y * this.width] = tileId;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/Playfield.ts?");

/***/ }),

/***/ "./src/Position.ts":
/*!*************************!*\
  !*** ./src/Position.ts ***!
  \*************************/
/*! exports provided: Position */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Position\", function() { return Position; });\nclass Position {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/Position.ts?");

/***/ }),

/***/ "./src/Shape.ts":
/*!**********************!*\
  !*** ./src/Shape.ts ***!
  \**********************/
/*! exports provided: Shape */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Shape\", function() { return Shape; });\n/* harmony import */ var _Position__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Position */ \"./src/Position.ts\");\n\nclass Shape {\n    constructor(tiles, image, sprite = 2, type) {\n        this.image = image;\n        this.type = type;\n        this.position = new _Position__WEBPACK_IMPORTED_MODULE_0__[\"Position\"](3, 0);\n        this.tiles = tiles;\n        this.spriteId = sprite;\n    }\n    draw(context) {\n        for (let y = 0; y < this.tiles.length; y++) {\n            for (let x = 0; x < this.tiles[y].length; x++) {\n                const num = this.tiles[y][x];\n                if (num === 1) {\n                    context.drawImage(this.image, 8 * this.spriteId, 0, 8, 8, this.position.x * 8 + x * 8, this.position.y * 8 + y * 8, 8, 8);\n                }\n            }\n        }\n    }\n    drawAt(context, pos) {\n        for (let y = 0; y < this.tiles.length; y++) {\n            for (let x = 0; x < this.tiles[y].length; x++) {\n                const num = this.tiles[y][x];\n                if (num === 1) {\n                    context.drawImage(this.image, 8 * this.spriteId, 0, 8, 8, pos.x + x * 8, pos.y + y * 8, 8, 8);\n                }\n            }\n        }\n    }\n    rotate() {\n        const temp = new Array(this.tiles[0].length);\n        for (let i = 0; i < this.tiles[0].length; i++) {\n            const arr = new Array(this.tiles.length);\n            arr.fill(0);\n            temp[i] = arr;\n        }\n        for (let y = 0; y < this.tiles.length; y++) {\n            for (let x = 0; x < this.tiles[y].length; x++) {\n                temp[x][this.tiles.length - 1 - y] = this.tiles[y][x];\n            }\n        }\n        this.tiles = temp;\n    }\n    getTiles() {\n        const tiles = Array();\n        for (let y = 0; y < this.tiles.length; y++) {\n            for (let x = 0; x < this.tiles[y].length; x++) {\n                const num = this.tiles[y][x];\n                if (num === 1) {\n                    tiles.push(new _Position__WEBPACK_IMPORTED_MODULE_0__[\"Position\"](x + this.position.x, y + this.position.y));\n                }\n            }\n        }\n        return tiles;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/Shape.ts?");

/***/ }),

/***/ "./src/ShapeSpawner.ts":
/*!*****************************!*\
  !*** ./src/ShapeSpawner.ts ***!
  \*****************************/
/*! exports provided: ShapeSpawner */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShapeSpawner\", function() { return ShapeSpawner; });\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shape */ \"./src/Shape.ts\");\n/* harmony import */ var _ShapeType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ShapeType */ \"./src/ShapeType.ts\");\n\n\nclass ShapeSpawner {\n    getNextShape(image) {\n        const random = Math.floor(Math.random() * 7);\n        // TODO: put into Array to slect by index\n        switch (random) {\n            case 0:\n                return new _Shape__WEBPACK_IMPORTED_MODULE_0__[\"Shape\"]([\n                    [1, 1],\n                    [1, 1],\n                ], image, 1, _ShapeType__WEBPACK_IMPORTED_MODULE_1__[\"ShapeType\"].O);\n            case 1:\n                return new _Shape__WEBPACK_IMPORTED_MODULE_0__[\"Shape\"]([\n                    [0, 1, 0],\n                    [1, 1, 1],\n                    [0, 0, 0]\n                ], image, 2, _ShapeType__WEBPACK_IMPORTED_MODULE_1__[\"ShapeType\"].T);\n            case 2:\n                return new _Shape__WEBPACK_IMPORTED_MODULE_0__[\"Shape\"]([\n                    [0, 0, 0, 0],\n                    [1, 1, 1, 1],\n                    [0, 0, 0, 0],\n                    [0, 0, 0, 0]\n                ], image, 3, _ShapeType__WEBPACK_IMPORTED_MODULE_1__[\"ShapeType\"].I);\n            case 3:\n                return new _Shape__WEBPACK_IMPORTED_MODULE_0__[\"Shape\"]([\n                    [1, 0, 0],\n                    [1, 1, 1],\n                    [0, 0, 0]\n                ], image, 4, _ShapeType__WEBPACK_IMPORTED_MODULE_1__[\"ShapeType\"].J);\n            case 4:\n                return new _Shape__WEBPACK_IMPORTED_MODULE_0__[\"Shape\"]([\n                    [0, 0, 1],\n                    [1, 1, 1],\n                    [0, 0, 0]\n                ], image, 1, _ShapeType__WEBPACK_IMPORTED_MODULE_1__[\"ShapeType\"].L);\n            case 5:\n                return new _Shape__WEBPACK_IMPORTED_MODULE_0__[\"Shape\"]([\n                    [0, 1, 1],\n                    [1, 1, 0],\n                    [0, 0, 0]\n                ], image, 2, _ShapeType__WEBPACK_IMPORTED_MODULE_1__[\"ShapeType\"].S);\n            case 6:\n                return new _Shape__WEBPACK_IMPORTED_MODULE_0__[\"Shape\"]([\n                    [1, 1, 0],\n                    [0, 1, 1],\n                    [0, 0, 0]\n                ], image, 3, _ShapeType__WEBPACK_IMPORTED_MODULE_1__[\"ShapeType\"].Z);\n        }\n    }\n}\n\n\n//# sourceURL=webpack:///./src/ShapeSpawner.ts?");

/***/ }),

/***/ "./src/ShapeType.ts":
/*!**************************!*\
  !*** ./src/ShapeType.ts ***!
  \**************************/
/*! exports provided: ShapeType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShapeType\", function() { return ShapeType; });\nvar ShapeType;\n(function (ShapeType) {\n    ShapeType[ShapeType[\"O\"] = 0] = \"O\";\n    ShapeType[ShapeType[\"T\"] = 1] = \"T\";\n    ShapeType[ShapeType[\"I\"] = 2] = \"I\";\n    ShapeType[ShapeType[\"J\"] = 3] = \"J\";\n    ShapeType[ShapeType[\"L\"] = 4] = \"L\";\n    ShapeType[ShapeType[\"Z\"] = 5] = \"Z\";\n    ShapeType[ShapeType[\"S\"] = 6] = \"S\";\n})(ShapeType || (ShapeType = {}));\n\n\n//# sourceURL=webpack:///./src/ShapeType.ts?");

/***/ }),

/***/ "./src/TetrisGame.ts":
/*!***************************!*\
  !*** ./src/TetrisGame.ts ***!
  \***************************/
/*! exports provided: TetrisGame */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TetrisGame\", function() { return TetrisGame; });\n/* harmony import */ var _Playfield__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Playfield */ \"./src/Playfield.ts\");\n/* harmony import */ var _Shape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Shape */ \"./src/Shape.ts\");\n/* harmony import */ var _ShapeSpawner__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ShapeSpawner */ \"./src/ShapeSpawner.ts\");\n/* harmony import */ var _sound_Sound__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sound/Sound */ \"./src/sound/Sound.ts\");\n/* harmony import */ var _Gamepad__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Gamepad */ \"./src/Gamepad.ts\");\n/* harmony import */ var _ShapeType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ShapeType */ \"./src/ShapeType.ts\");\n\n\n\n\n\n\nclass TetrisGame {\n    constructor(context, image, soundManager) {\n        this.soundManager = soundManager;\n        this.score = 0;\n        this.state = 0;\n        this.level = 0;\n        this.lineCounter = 0;\n        this.oldDropTime = 0;\n        this.nextDropTime = Date.now();\n        this.deathTime = Date.now();\n        this.startLevel = 0;\n        this.rotatePressed = false;\n        this.inputElapsedTime = Date.now();\n        this.gamepad = new _Gamepad__WEBPACK_IMPORTED_MODULE_4__[\"Gamepad2\"]();\n        this.image = image;\n        this.statistics = new Map();\n        this.statistics.set(_ShapeType__WEBPACK_IMPORTED_MODULE_5__[\"ShapeType\"].I, 0);\n        this.statistics.set(_ShapeType__WEBPACK_IMPORTED_MODULE_5__[\"ShapeType\"].J, 0);\n        this.statistics.set(_ShapeType__WEBPACK_IMPORTED_MODULE_5__[\"ShapeType\"].L, 0);\n        this.statistics.set(_ShapeType__WEBPACK_IMPORTED_MODULE_5__[\"ShapeType\"].O, 0);\n        this.statistics.set(_ShapeType__WEBPACK_IMPORTED_MODULE_5__[\"ShapeType\"].S, 0);\n        this.statistics.set(_ShapeType__WEBPACK_IMPORTED_MODULE_5__[\"ShapeType\"].T, 0);\n        this.statistics.set(_ShapeType__WEBPACK_IMPORTED_MODULE_5__[\"ShapeType\"].Z, 0);\n        this.field = new _Playfield__WEBPACK_IMPORTED_MODULE_0__[\"Playfield\"](10, 20, this.image);\n        this.futureShape = new _ShapeSpawner__WEBPACK_IMPORTED_MODULE_2__[\"ShapeSpawner\"]().getNextShape(this.image);\n        this.emitNewShape();\n    }\n    setStartLevel(level) {\n        this.startLevel = level;\n        this.level = level;\n    }\n    start() {\n        this.nextDropTime = Date.now();\n    }\n    getStatistics() {\n        return this.statistics;\n    }\n    emitNewShape() {\n        this.statistics.set(this.futureShape.type, this.statistics.get(this.futureShape.type) + 1);\n        this.shape = this.futureShape;\n        this.futureShape = new _ShapeSpawner__WEBPACK_IMPORTED_MODULE_2__[\"ShapeSpawner\"]().getNextShape(this.image);\n        // add here\n        if (this.field.collides(this.shape)) {\n            // game over\n            this.state = 2;\n            this.deathTime = this.nextDropTime;\n        }\n    }\n    update() {\n        if (this.gamepad.isButtonPressed(0) && !this.rotatePressed) {\n            this.rotatePressed = true;\n            this.rotateClockwise();\n        }\n        if (!this.gamepad.isButtonPressed(0)) {\n            this.rotatePressed = false;\n        }\n        if (Date.now() > this.inputElapsedTime + 100) {\n            if (this.gamepad.isLeft(0, -1)) {\n                this.moveLeft();\n            }\n            if (this.gamepad.isLeft(0, 1)) {\n                this.moveRight();\n            }\n            if (this.gamepad.isLeft(1, 1)) {\n                this.moveDown();\n            }\n            this.inputElapsedTime = Date.now();\n        }\n        if (this.state === 0) {\n            if (this.shape !== null) {\n                if (Date.now() >= this.nextDropTime) {\n                    this.moveDown();\n                }\n            }\n        }\n        else if (this.state === 1) {\n            if (Date.now() >= this.nextDropTime) {\n                const fullRows = this.field.getNumberOfFullRows();\n                this.updateScore(this.level, fullRows);\n                this.field.removeFullRows();\n                this.lineCounter += fullRows;\n                const firstLevelStep = Math.min(this.startLevel * 10 + 10, Math.max(100, this.startLevel * 10 - 50));\n                this.level = Math.floor(Math.max(this.lineCounter - firstLevelStep, 0) / 10) +\n                    (this.lineCounter >= firstLevelStep ? 1 : 0) + this.startLevel;\n                this.state = 0;\n            }\n        }\n    }\n    getField() {\n        return this.field;\n    }\n    getShape() {\n        return this.shape;\n    }\n    getFuture() {\n        return this.futureShape;\n    }\n    getGhost() {\n        const ghost = new _Shape__WEBPACK_IMPORTED_MODULE_1__[\"Shape\"](this.shape.tiles, this.image, 9, this.shape.type);\n        ghost.position.y = this.shape.position.y;\n        ghost.position.x = this.shape.position.x;\n        do {\n            ghost.position.y += 1;\n        } while (!this.field.collides(ghost));\n        ghost.position.y -= 1;\n        return ghost;\n    }\n    moveLeft() {\n        this.shape.position.x -= 1;\n        if (this.field.collides(this.shape)) {\n            this.shape.position.x += 1;\n        }\n    }\n    moveRight() {\n        this.shape.position.x += 1;\n        if (this.field.collides(this.shape)) {\n            this.shape.position.x -= 1;\n        }\n    }\n    rotateCounterclockwise() {\n        const oldTiles = this.shape.tiles;\n        this.shape.rotate();\n        this.shape.rotate();\n        this.shape.rotate();\n        if (this.field.collides(this.shape)) {\n            this.shape.tiles = oldTiles;\n        }\n        else {\n            this.soundManager.play(_sound_Sound__WEBPACK_IMPORTED_MODULE_3__[\"Sound\"].ROTATION);\n        }\n    }\n    rotateClockwise() {\n        const oldTiles = this.shape.tiles;\n        this.shape.rotate();\n        if (this.field.collides(this.shape)) {\n            this.shape.tiles = oldTiles;\n        }\n        else {\n            this.soundManager.play(_sound_Sound__WEBPACK_IMPORTED_MODULE_3__[\"Sound\"].ROTATION);\n        }\n    }\n    moveDown() {\n        if (this.state === 2) {\n            return;\n        }\n        this.shape.position.y += 1;\n        if (this.field.collides(this.shape)) {\n            this.onCollide();\n        }\n        else {\n            this.oldDropTime = this.nextDropTime;\n            this.nextDropTime = this.oldDropTime + this.getTetrominoSpeedInMillis(this.level);\n        }\n    }\n    onCollide() {\n        this.soundManager.play(_sound_Sound__WEBPACK_IMPORTED_MODULE_3__[\"Sound\"].DROP);\n        this.shape.position.y -= 1;\n        this.field.setBlocks(this.shape);\n        this.emitNewShape();\n        this.oldDropTime = this.nextDropTime;\n        if (this.field.hasFullRows()) {\n            this.soundManager.play(_sound_Sound__WEBPACK_IMPORTED_MODULE_3__[\"Sound\"].REMOVE_ROWS);\n            this.fullRows = this.field.getfFullRows();\n            this.nextDropTime = this.oldDropTime + TetrisGame.FULL_ROW_ANIMATION_DELAY;\n            this.state = 1;\n        }\n        else {\n            this.nextDropTime = this.oldDropTime + TetrisGame.DELAY_AFTER_DROP;\n        }\n    }\n    hardDrop() {\n        if (this.state === 2) {\n            return;\n        }\n        do {\n            this.shape.position.y += 1;\n        } while (!this.field.collides(this.shape));\n        this.nextDropTime = Date.now();\n        this.onCollide();\n    }\n    // uses original nintendo scoring system used in NES, GB and SNES versions\n    updateScore(currentLevel, numLines) {\n        let lineScore = 0;\n        switch (numLines) {\n            case 1:\n                lineScore = 40;\n                break;\n            case 2:\n                lineScore = 100;\n                break;\n            case 3:\n                lineScore = 300;\n                break;\n            case 4:\n                lineScore = 1200;\n                break;\n        }\n        this.score += lineScore * (currentLevel + 1);\n    }\n    getTetrominoSpeedInMillis(currentLevel) {\n        return this.convertFrameToMilliseconds(this.convertLevelToFramesPerGridCell(currentLevel));\n    }\n    convertFrameToMilliseconds(frames) {\n        const NES_FPS = 60.098814;\n        return 1000 / NES_FPS * frames;\n    }\n    convertLevelToFramesPerGridCell(currentLevel) {\n        if (currentLevel === 0) {\n            return 48;\n        }\n        else if (currentLevel === 1) {\n            return 43;\n        }\n        else if (currentLevel === 2) {\n            return 38;\n        }\n        else if (currentLevel === 3) {\n            return 33;\n        }\n        else if (currentLevel === 4) {\n            return 28;\n        }\n        else if (currentLevel === 5) {\n            return 23;\n        }\n        else if (currentLevel === 6) {\n            return 18;\n        }\n        else if (currentLevel === 7) {\n            return 13;\n        }\n        else if (currentLevel === 8) {\n            return 8;\n        }\n        else if (currentLevel === 9) {\n            return 6;\n        }\n        else if (currentLevel >= 10 && currentLevel <= 12) {\n            return 5;\n        }\n        else if (currentLevel >= 13 && currentLevel <= 15) {\n            return 4;\n        }\n        else if (currentLevel >= 16 && currentLevel <= 18) {\n            return 3;\n        }\n        else if (currentLevel >= 19 && currentLevel <= 28) {\n            return 2;\n        }\n        else if (currentLevel >= 29) {\n            return 1;\n        }\n    }\n}\nTetrisGame.FULL_ROW_ANIMATION_DELAY = 500;\nTetrisGame.DELAY_AFTER_DROP = 500;\n\n\n//# sourceURL=webpack:///./src/TetrisGame.ts?");

/***/ }),

/***/ "./src/assets/arrows.png":
/*!*******************************!*\
  !*** ./src/assets/arrows.png ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"bf049350ab276e5cbac30f53ce435553.png\";\n\n//# sourceURL=webpack:///./src/assets/arrows.png?");

/***/ }),

/***/ "./src/assets/background.png":
/*!***********************************!*\
  !*** ./src/assets/background.png ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"64aaf93c24abdffb3b22ec451686bfb0.png\";\n\n//# sourceURL=webpack:///./src/assets/background.png?");

/***/ }),

/***/ "./src/assets/block-rotate.mp3":
/*!*************************************!*\
  !*** ./src/assets/block-rotate.mp3 ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"63fb42473eb1310a894e3b3684606e2e.mp3\";\n\n//# sourceURL=webpack:///./src/assets/block-rotate.mp3?");

/***/ }),

/***/ "./src/assets/congratulations.png":
/*!****************************************!*\
  !*** ./src/assets/congratulations.png ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"32e5246303dc4f955784d3991447c259.png\";\n\n//# sourceURL=webpack:///./src/assets/congratulations.png?");

/***/ }),

/***/ "./src/assets/credits.png":
/*!********************************!*\
  !*** ./src/assets/credits.png ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"5550a864c1e8a351dd27ed0eaed1700a.png\";\n\n//# sourceURL=webpack:///./src/assets/credits.png?");

/***/ }),

/***/ "./src/assets/digits-red.png":
/*!***********************************!*\
  !*** ./src/assets/digits-red.png ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"dbad76798016761b58cdee10c15896d5.png\";\n\n//# sourceURL=webpack:///./src/assets/digits-red.png?");

/***/ }),

/***/ "./src/assets/digits.png":
/*!*******************************!*\
  !*** ./src/assets/digits.png ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"e4ca3299a1f7fbbd22f51242f2594902.png\";\n\n//# sourceURL=webpack:///./src/assets/digits.png?");

/***/ }),

/***/ "./src/assets/drop.ogg":
/*!*****************************!*\
  !*** ./src/assets/drop.ogg ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"6dedea8612bb407c423d3c22e4e48f35.ogg\";\n\n//# sourceURL=webpack:///./src/assets/drop.ogg?");

/***/ }),

/***/ "./src/assets/font2.png":
/*!******************************!*\
  !*** ./src/assets/font2.png ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"ffa3cfb5f870330b7d2bf88e7842f214.png\";\n\n//# sourceURL=webpack:///./src/assets/font2.png?");

/***/ }),

/***/ "./src/assets/line-removal.mp3":
/*!*************************************!*\
  !*** ./src/assets/line-removal.mp3 ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"2c6dec5408606ce3bb82cdc83834229a.mp3\";\n\n//# sourceURL=webpack:///./src/assets/line-removal.mp3?");

/***/ }),

/***/ "./src/assets/main-menu.png":
/*!**********************************!*\
  !*** ./src/assets/main-menu.png ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"04c7714461b7667097960bf9ba954384.png\";\n\n//# sourceURL=webpack:///./src/assets/main-menu.png?");

/***/ }),

/***/ "./src/assets/menu-level.png":
/*!***********************************!*\
  !*** ./src/assets/menu-level.png ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"088a53fbcfa7246455e4b676308edaea.png\";\n\n//# sourceURL=webpack:///./src/assets/menu-level.png?");

/***/ }),

/***/ "./src/assets/menuS.wav":
/*!******************************!*\
  !*** ./src/assets/menuS.wav ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"2c74851462f2341a4e6e214ad9326b74.wav\";\n\n//# sourceURL=webpack:///./src/assets/menuS.wav?");

/***/ }),

/***/ "./src/assets/music/tetris ingame.xm":
/*!*******************************************!*\
  !*** ./src/assets/music/tetris ingame.xm ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"afcc7023148c4f9319e0d6e9ff716549.xm\";\n\n//# sourceURL=webpack:///./src/assets/music/tetris_ingame.xm?");

/***/ }),

/***/ "./src/assets/music/tetris ingame2.xm":
/*!********************************************!*\
  !*** ./src/assets/music/tetris ingame2.xm ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"2f1ca0ab1213f91c6816389fa121f6b0.xm\";\n\n//# sourceURL=webpack:///./src/assets/music/tetris_ingame2.xm?");

/***/ }),

/***/ "./src/assets/music/tetris ingame3.xm":
/*!********************************************!*\
  !*** ./src/assets/music/tetris ingame3.xm ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"372880e6d057752250fa8820760b45a2.xm\";\n\n//# sourceURL=webpack:///./src/assets/music/tetris_ingame3.xm?");

/***/ }),

/***/ "./src/assets/sprites2.png":
/*!*********************************!*\
  !*** ./src/assets/sprites2.png ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"bfb1af668c0675ffd207959a4e50bdc1.png\";\n\n//# sourceURL=webpack:///./src/assets/sprites2.png?");

/***/ }),

/***/ "./src/assets/title.png":
/*!******************************!*\
  !*** ./src/assets/title.png ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"ea8d100a21bd97b8675c230d056ef0a3.png\";\n\n//# sourceURL=webpack:///./src/assets/title.png?");

/***/ }),

/***/ "./src/fullscreen/FullscreenUtils.ts":
/*!*******************************************!*\
  !*** ./src/fullscreen/FullscreenUtils.ts ***!
  \*******************************************/
/*! exports provided: FullscreenUtils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FullscreenUtils\", function() { return FullscreenUtils; });\nclass FullscreenUtils {\n    static fullscreen(stuff) {\n        const doc = stuff;\n        if ('requestFullscreen' in doc) {\n            doc['requestFullscreen']();\n        }\n        else if ('webkitRequestFullScreen' in doc) {\n            doc['webkitRequestFullScreen']();\n        }\n        else if ('mozRequestFullScreen' in doc) {\n            doc['mozRequestFullScreen']();\n        }\n        else if ('msRequestFullscreen' in doc) {\n            doc['msRequestFullscreen']();\n        }\n    }\n}\n\n\n//# sourceURL=webpack:///./src/fullscreen/FullscreenUtils.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _assets_block_rotate_mp3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assets/block-rotate.mp3 */ \"./src/assets/block-rotate.mp3\");\n/* harmony import */ var _assets_block_rotate_mp3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_assets_block_rotate_mp3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _assets_line_removal_mp3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assets/line-removal.mp3 */ \"./src/assets/line-removal.mp3\");\n/* harmony import */ var _assets_line_removal_mp3__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_assets_line_removal_mp3__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _assets_menuS_wav__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./assets/menuS.wav */ \"./src/assets/menuS.wav\");\n/* harmony import */ var _assets_menuS_wav__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_assets_menuS_wav__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _assets_drop_ogg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./assets/drop.ogg */ \"./src/assets/drop.ogg\");\n/* harmony import */ var _assets_drop_ogg__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_assets_drop_ogg__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _assets_arrows_png__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./assets/arrows.png */ \"./src/assets/arrows.png\");\n/* harmony import */ var _assets_arrows_png__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_assets_arrows_png__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _assets_background_png__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./assets/background.png */ \"./src/assets/background.png\");\n/* harmony import */ var _assets_background_png__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_assets_background_png__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _assets_congratulations_png__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./assets/congratulations.png */ \"./src/assets/congratulations.png\");\n/* harmony import */ var _assets_congratulations_png__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_assets_congratulations_png__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _assets_credits_png__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./assets/credits.png */ \"./src/assets/credits.png\");\n/* harmony import */ var _assets_credits_png__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_assets_credits_png__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _assets_digits_red_png__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./assets/digits-red.png */ \"./src/assets/digits-red.png\");\n/* harmony import */ var _assets_digits_red_png__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_assets_digits_red_png__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _assets_digits_png__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./assets/digits.png */ \"./src/assets/digits.png\");\n/* harmony import */ var _assets_digits_png__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_assets_digits_png__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var _assets_font2_png__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./assets/font2.png */ \"./src/assets/font2.png\");\n/* harmony import */ var _assets_font2_png__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_assets_font2_png__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var _assets_main_menu_png__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./assets/main-menu.png */ \"./src/assets/main-menu.png\");\n/* harmony import */ var _assets_main_menu_png__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_assets_main_menu_png__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var _assets_menu_level_png__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./assets/menu-level.png */ \"./src/assets/menu-level.png\");\n/* harmony import */ var _assets_menu_level_png__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_assets_menu_level_png__WEBPACK_IMPORTED_MODULE_12__);\n/* harmony import */ var _assets_sprites2_png__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./assets/sprites2.png */ \"./src/assets/sprites2.png\");\n/* harmony import */ var _assets_sprites2_png__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_assets_sprites2_png__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var _assets_title_png__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./assets/title.png */ \"./src/assets/title.png\");\n/* harmony import */ var _assets_title_png__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_assets_title_png__WEBPACK_IMPORTED_MODULE_14__);\n/* harmony import */ var _fullscreen_FullscreenUtils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./fullscreen/FullscreenUtils */ \"./src/fullscreen/FullscreenUtils.ts\");\n/* harmony import */ var _Position__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./Position */ \"./src/Position.ts\");\n/* harmony import */ var _TetrisGame__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./TetrisGame */ \"./src/TetrisGame.ts\");\n/* harmony import */ var _ShapeType__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./ShapeType */ \"./src/ShapeType.ts\");\n/* harmony import */ var _sound_SoundManager__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./sound/SoundManager */ \"./src/sound/SoundManager.ts\");\n/* harmony import */ var jsxm_xm__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! jsxm/xm */ \"./node_modules/jsxm/xm.js\");\n/* harmony import */ var jsxm_xm__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/__webpack_require__.n(jsxm_xm__WEBPACK_IMPORTED_MODULE_20__);\n/* harmony import */ var jsxm_xmeffects__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! jsxm/xmeffects */ \"./node_modules/jsxm/xmeffects.js\");\n/* harmony import */ var jsxm_xmeffects__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/__webpack_require__.n(jsxm_xmeffects__WEBPACK_IMPORTED_MODULE_21__);\n/* harmony import */ var _OptionList__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./OptionList */ \"./src/OptionList.ts\");\n/* harmony import */ var _sound_Sound__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./sound/Sound */ \"./src/sound/Sound.ts\");\n/**\n * TODO:\n * - bug: hard drop during erase animation retriggers animation!\n * - bug: soft drop / hard drop does not stop after collision (next tetromino also drops immediately)\n * - a type congratulations screen\n * - different colors per level\n * - Add state machine or state class!\n * - Remove render code and move into render class\n * - Asset preloader\n * - colored fonts: https://github.com/geoffb/canvas-bitmap-fonts/blob/master/index.html\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst canvas = document.createElement('canvas');\ncanvas.width = 256;\ncanvas.height = 224;\ncanvas.style.cssText = 'image-rendering: optimizeSpeed;' + // FireFox < 6.0\n    'image-rendering: -moz-crisp-edges;' + // FireFox\n    'image-rendering: -o-crisp-edges;' + // Opera\n    'image-rendering: -webkit-crisp-edges;' + // Chrome\n    'image-rendering: crisp-edges;' + // Chrome\n    'image-rendering: -webkit-optimize-contrast;' + // Safari\n    'image-rendering: pixelated; ' + // Future browsers\n    '-ms-interpolation-mode: nearest-neighbor;'; // IE\ncanvas.style.width = `${256 * 2}px`;\ncanvas.style.height = `${224 * 2}px`;\ndocument.body.appendChild(canvas);\nconst context = canvas.getContext('2d');\nconst image = new Image();\nimage.src = _assets_background_png__WEBPACK_IMPORTED_MODULE_5___default.a;\nconst digitsImage = new Image();\ndigitsImage.src = _assets_digits_png__WEBPACK_IMPORTED_MODULE_9___default.a;\nconst fonts2Image = new Image();\nfonts2Image.src = _assets_font2_png__WEBPACK_IMPORTED_MODULE_10___default.a;\nconst creditsImage = new Image();\ncreditsImage.src = _assets_credits_png__WEBPACK_IMPORTED_MODULE_7___default.a;\nconst congratsImage = new Image();\ncongratsImage.src = _assets_congratulations_png__WEBPACK_IMPORTED_MODULE_6___default.a;\nconst digits2Image = new Image();\ndigits2Image.src = _assets_digits_red_png__WEBPACK_IMPORTED_MODULE_8___default.a;\nconst arrowsImage = new Image();\narrowsImage.src = _assets_arrows_png__WEBPACK_IMPORTED_MODULE_4___default.a;\nconst menuImage = new Image();\nmenuImage.src = _assets_title_png__WEBPACK_IMPORTED_MODULE_14___default.a;\nconst menuImage2 = new Image();\nmenuImage2.src = _assets_main_menu_png__WEBPACK_IMPORTED_MODULE_11___default.a;\nconst menuImage3 = new Image();\nmenuImage3.src = _assets_menu_level_png__WEBPACK_IMPORTED_MODULE_12___default.a;\nlet tetris;\nconst sm = new _sound_SoundManager__WEBPACK_IMPORTED_MODULE_19__[\"SoundManager\"]();\nsm.loadSound(_sound_Sound__WEBPACK_IMPORTED_MODULE_23__[\"Sound\"].DROP, _assets_drop_ogg__WEBPACK_IMPORTED_MODULE_3___default.a);\nsm.loadSound(_sound_Sound__WEBPACK_IMPORTED_MODULE_23__[\"Sound\"].REMOVE_ROWS, _assets_line_removal_mp3__WEBPACK_IMPORTED_MODULE_1___default.a);\nsm.loadSound(_sound_Sound__WEBPACK_IMPORTED_MODULE_23__[\"Sound\"].ROTATION, _assets_block_rotate_mp3__WEBPACK_IMPORTED_MODULE_0___default.a);\nsm.loadSound(99, _assets_menuS_wav__WEBPACK_IMPORTED_MODULE_2___default.a);\nlet musicTypeOptions;\nlet music = [];\nconst imageSp = new Image();\nimageSp.onload = () => {\n    tetris = new _TetrisGame__WEBPACK_IMPORTED_MODULE_17__[\"TetrisGame\"](context, imageSp, sm);\n    Promise.all([\n        sm.loadExtendedModule(__webpack_require__(/*! ./assets/music/tetris ingame.xm */ \"./src/assets/music/tetris ingame.xm\")),\n        sm.loadExtendedModule(__webpack_require__(/*! ./assets/music/tetris ingame2.xm */ \"./src/assets/music/tetris ingame2.xm\")),\n        sm.loadExtendedModule(__webpack_require__(/*! ./assets/music/tetris ingame3.xm */ \"./src/assets/music/tetris ingame3.xm\"))\n    ]).then((res) => {\n        music = res;\n        musicTypeOptions = new _OptionList__WEBPACK_IMPORTED_MODULE_22__[\"OptionList\"]([\n            res[0], res[1], res[2], null\n        ], 0);\n        musicTypeOptions.addChangeListener((t) => {\n            XMPlayer.stop();\n            if (t !== null) {\n                XMPlayer.load(t);\n                XMPlayer.play();\n            }\n        });\n        requestAnimationFrame(() => draw());\n    });\n};\nimageSp.src = _assets_sprites2_png__WEBPACK_IMPORTED_MODULE_13___default.a;\nlet state = 0;\nconst gameTypeOptions = new _OptionList__WEBPACK_IMPORTED_MODULE_22__[\"OptionList\"]([0, 1], 0);\nconst levelTypeOptions = new _OptionList__WEBPACK_IMPORTED_MODULE_22__[\"OptionList\"]([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 0);\nconst charOrder = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789,/()\". -';\nconst allChars = charOrder.split('');\nlet nameOption = null;\nclass HightScore {\n    constructor(name, score, level) {\n        this.name = name;\n        this.score = score;\n        this.level = level;\n    }\n}\nconst highScoreList = [\n    new HightScore('JOHANN', 10000, 9),\n    new HightScore('OTASAN', 7500, 5),\n    new HightScore('LANCE ', 100, 0)\n];\nlet hightScoreIndex = 0;\nlet highScore = null;\nfunction draw() {\n    if (state === 0) {\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        context.drawImage(creditsImage, 0, 0, 256, 224, 0, 0, 256, 224);\n    }\n    else if (state === 1) {\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        context.drawImage(menuImage, 0, 0, 256, 224, 0, 0, 256, 224);\n    }\n    else if (state === 2) {\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        context.drawImage(menuImage2, 0, 0, 256, 224, 0, 0, 256, 224);\n        drawArrows(63 + gameTypeOptions.getOption() * 96, 55, 58);\n        drawArrows(103, 135 + musicTypeOptions.getIndex() * 16, 74);\n    }\n    else if (state === 3) {\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        context.drawImage(menuImage3, 0, 0, 256, 224, 0, 0, 256, 224);\n        drawSelectedLevel();\n    }\n    else if (state === 5) {\n        // enter name!\n        //\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        context.drawImage(congratsImage, 0, 0, 256, 224, 0, 0, 256, 224);\n        // color of curso #ff9047\n        const row = nameOption.getIndex();\n        context.fillStyle = '#ff9047';\n        const flicker = Math.floor(Date.now() * 0.01) % 2;\n        if (flicker === 1) {\n            context.globalAlpha = 0;\n        }\n        else {\n            context.globalAlpha = 0.75;\n        }\n        context.fillRect(56 + 8 + 8 + row * 8, 152 + hightScoreIndex * 16, 8, 8);\n        context.globalAlpha = 1;\n        for (let i = 0; i < highScoreList.length; i++) {\n            const entry = (i + 1).toString() + ' ' + highScoreList[i].name + ' '\n                + pad(highScoreList[i].score.toString(), 6, '0') + ' ' + pad(highScoreList[i].level.toString(), 2, '0');\n            drawText(56, 152 + i * 16, entry);\n        }\n    }\n    else {\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        context.fillStyle = '#222222';\n        context.fillRect(0, 0, 640, 360);\n        context.drawImage(image, 0, 0, 256, 224, 0, 0, 256, 224);\n        if (tetris.state !== 2) {\n            tetris.update();\n        }\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        tetris.getField().draw(context);\n        const shape = tetris.getShape();\n        if (shape !== null) {\n            shape.draw(context);\n        }\n        if (tetris.state === 2) {\n            drawDeath();\n            context.setTransform(1, 0, 0, 1, 0, 0);\n            context.fillStyle = '#000000';\n            context.fillRect(8 * 12.5 - 4, 8 * 14 - 4, 8 * 10, 8 * 2);\n            drawText(8 * 12.5, 8 * 14, 'GAME OVER');\n        }\n        context.globalAlpha = 0.24;\n        tetris.getGhost().draw(context);\n        context.globalAlpha = 1;\n        drawNextShape();\n        drawStatistics();\n        if (tetris.state === 1) {\n            drawRemoval();\n        }\n    }\n    requestAnimationFrame(() => draw());\n}\nfunction drawSelectedLevel() {\n    const column = levelTypeOptions.getIndex() % 5;\n    const row = Math.floor(levelTypeOptions.getIndex() / 5);\n    context.fillStyle = '#ffff00';\n    const flicker = Math.floor(Date.now() * 0.02) % 2;\n    if (flicker === 1) {\n        context.globalAlpha = 0;\n    }\n    else {\n        context.globalAlpha = 0.75;\n    }\n    context.fillRect(column * 16 + 52, row * 16 + 76, 16, 16);\n    context.globalAlpha = 1;\n    for (let i = 0; i < 10; i++) {\n        drawText(56 + (i % 5) * 16, 80 + Math.floor(i / 5) * 16, i.toString());\n    }\n    for (let i = 0; i < highScoreList.length; i++) {\n        const entry = (i + 1).toString() + ' ' + highScoreList[i].name + ' '\n            + pad(highScoreList[i].score.toString(), 6, '0') + ' ' + pad(highScoreList[i].level.toString(), 2, '0');\n        drawText(56, 152 + i * 16, entry);\n    }\n}\nfunction drawRemoval() {\n    context.translate(96, 40);\n    const scale = (Date.now() - tetris.oldDropTime) / _TetrisGame__WEBPACK_IMPORTED_MODULE_17__[\"TetrisGame\"].FULL_ROW_ANIMATION_DELAY;\n    const time = Math.floor(Math.max(0, Math.min(5.0, 6 * scale)));\n    context.fillStyle = 'black';\n    tetris.fullRows.forEach((x) => {\n        context.fillRect(5 * 8 - time * 8, x * 8, time * 8 * 2, 8);\n    });\n    if (tetris.fullRows.length === 4) {\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        const flicker = Math.floor(Date.now() * 0.02) % 2;\n        context.fillStyle = 'white';\n        if (flicker === 1) {\n            context.globalAlpha = 0;\n        }\n        else {\n            context.globalAlpha = 0.75;\n        }\n        context.fillRect(0, 0, 256, 224);\n        context.globalAlpha = 1;\n    }\n}\nfunction drawDeath() {\n    context.setTransform(1, 0, 0, 1, 0, 0);\n    context.translate(96, 40);\n    const scale = 0.0006;\n    const diff = Math.min(Math.max((Date.now() - tetris.deathTime) * scale, 0), 1);\n    for (let y = 0; y < Math.floor(20 * diff); y++) {\n        for (let x = 0; x < 10; x++) {\n            context.drawImage(imageSp, 5 * 8, 0, 8, 8, x * 8, y * 8, 8, 8);\n        }\n    }\n}\nfunction drawNextShape() {\n    context.setTransform(1, 0, 0, 1, 0, 0);\n    const shape = tetris.getFuture();\n    const height = shape.tiles.length * 8;\n    const width = shape.tiles[0].length * 8;\n    shape.drawAt(context, new _Position__WEBPACK_IMPORTED_MODULE_16__[\"Position\"](208 - width / 2, 124 - height / 2));\n}\nfunction pad(orig, length, char) {\n    const leng = orig.length;\n    return char.repeat(Math.max(0, length - leng)) + orig;\n}\nfunction drawStatistics() {\n    drawNum(152, 16, pad(tetris.lineCounter.toString(), 3, '0')); // 3\n    drawNum(192, 56, pad(tetris.score.toString(), 6, '0')); // 6\n    drawNum(192, 32, pad('31337', 6, '0')); // 3\n    drawNum(208, 160, pad(tetris.level.toString(), 2, '0')); // 2\n    drawNum(48, 88, pad(tetris.getStatistics().get(_ShapeType__WEBPACK_IMPORTED_MODULE_18__[\"ShapeType\"].T).toString(), 3, '0'), true); // 3\n    drawNum(48, 88 + 16, pad(tetris.getStatistics().get(_ShapeType__WEBPACK_IMPORTED_MODULE_18__[\"ShapeType\"].J).toString(), 3, '0'), true); // 3\n    drawNum(48, 88 + 16 + 16, pad(tetris.getStatistics().get(_ShapeType__WEBPACK_IMPORTED_MODULE_18__[\"ShapeType\"].Z).toString(), 3, '0'), true); // 3\n    drawNum(48, 88 + 16 + 16 + 16, pad(tetris.getStatistics().get(_ShapeType__WEBPACK_IMPORTED_MODULE_18__[\"ShapeType\"].O).toString(), 3, '0'), true); // 3\n    drawNum(48, 88 + 16 + 16 + 16 + 16, pad(tetris.getStatistics().get(_ShapeType__WEBPACK_IMPORTED_MODULE_18__[\"ShapeType\"].S).toString(), 3, '0'), true); // 3\n    drawNum(48, 88 + 16 + 16 + 16 + 16 + 16, pad(tetris.getStatistics().get(_ShapeType__WEBPACK_IMPORTED_MODULE_18__[\"ShapeType\"].L).toString(), 3, '0'), true); // 3\n    drawNum(48, 88 + 16 + 16 + 16 + 16 + 16 + 16, pad(tetris.getStatistics().get(_ShapeType__WEBPACK_IMPORTED_MODULE_18__[\"ShapeType\"].I).toString(), 3, '0'), true); // 3\n}\nfunction drawNum(x, y, num, red = false) {\n    const myNum = '' + num;\n    const img = red ? digits2Image : digitsImage;\n    for (let i = 0; i < myNum.length; i++) {\n        drawDigit(x + i * 8, y, myNum.charCodeAt(i), img);\n    }\n}\nfunction drawDigit(x, y, char, img) {\n    const index = char - '0'.charCodeAt(0);\n    context.drawImage(img, 8 * index, 0, 8, 8, x, y, 8, 8);\n}\nfunction drawText(x, y, text) {\n    const img = fonts2Image;\n    for (let i = 0; i < text.length; i++) {\n        drawChar(x + i * 8, y, text.charCodeAt(i), img);\n    }\n}\nfunction drawChar(x, y, char, img) {\n    const index = char - ' '.charCodeAt(0);\n    const yIndex = Math.floor(index / 32);\n    const xIndex = Math.floor(index % 32);\n    context.drawImage(img, 8 * xIndex, 8 * yIndex, 8, 8, x, y, 8, 8);\n}\nfunction drawArrows(x, y, width) {\n    const flicker = Math.floor(Date.now() * 0.02) % 2;\n    context.fillStyle = 'white';\n    if (flicker === 1) {\n        context.globalAlpha = 0;\n    }\n    else {\n        context.globalAlpha = 1;\n    }\n    context.drawImage(arrowsImage, 0, 0, 8, 8, x, y, 8, 8);\n    context.drawImage(arrowsImage, 8, 0, 8, 8, x + width, y, 8, 8);\n    context.globalAlpha = 1;\n}\nconst KEY_DOWN_EVENT_LISTENER = 'keydown';\ndocument.addEventListener(KEY_DOWN_EVENT_LISTENER, (event) => {\n    if (event.keyCode === 70) {\n        _fullscreen_FullscreenUtils__WEBPACK_IMPORTED_MODULE_15__[\"FullscreenUtils\"].fullscreen(canvas);\n    }\n    if (event.keyCode === 37) {\n        if (state === 4) {\n            tetris.moveLeft();\n        }\n        if (state === 2) {\n            gameTypeOptions.previous();\n            sm.play(99);\n        }\n        if (state === 3) {\n            levelTypeOptions.previous();\n            sm.play(99);\n        }\n        if (state === 5) {\n            nameOption.previous();\n        }\n    }\n    if (event.keyCode === 39) {\n        if (state === 4) {\n            tetris.moveRight();\n        }\n        if (state === 2) {\n            gameTypeOptions.next();\n            sm.play(99);\n        }\n        if (state === 3) {\n            levelTypeOptions.next();\n            sm.play(99);\n        }\n        if (state === 5) {\n            nameOption.next();\n        }\n    }\n    if (event.keyCode === 38) {\n        if (state === 4) {\n            tetris.rotateClockwise();\n        }\n        if (state === 2) {\n            musicTypeOptions.previous();\n            sm.play(99);\n        }\n        if (state === 5) {\n            nameOption.getOption().next();\n            const options = nameOption.getOptions();\n            let newName = '';\n            for (let i = 0; i < options.length; i++) {\n                newName += options[i].getOption();\n            }\n            highScore.name = newName;\n        }\n    }\n    // rotate counter clockwhise: y\n    if (event.keyCode === 89) {\n        if (state === 4) {\n            tetris.rotateCounterclockwise();\n        }\n    }\n    if (event.keyCode === 83) {\n        if (state === 3) {\n            tetris.setStartLevel(levelTypeOptions.getIndex());\n            tetris.start();\n        }\n        if (state === 0 || state === 1 || state === 2 || state === 3) {\n            if (state === 1) {\n                musicTypeOptions.triggerCallback();\n            }\n            state++;\n        }\n        else if (state === 4 && tetris.state === 2) {\n            XMPlayer.stop();\n            if (tetris.score > highScoreList[2].score) {\n                const charOptions1 = new _OptionList__WEBPACK_IMPORTED_MODULE_22__[\"OptionList\"](allChars, allChars.length - 1, true);\n                const charOptions2 = new _OptionList__WEBPACK_IMPORTED_MODULE_22__[\"OptionList\"](allChars, allChars.length - 1, true);\n                const charOptions3 = new _OptionList__WEBPACK_IMPORTED_MODULE_22__[\"OptionList\"](allChars, allChars.length - 1, true);\n                const charOptions4 = new _OptionList__WEBPACK_IMPORTED_MODULE_22__[\"OptionList\"](allChars, allChars.length - 1, true);\n                const charOptions5 = new _OptionList__WEBPACK_IMPORTED_MODULE_22__[\"OptionList\"](allChars, allChars.length - 1, true);\n                const charOptions6 = new _OptionList__WEBPACK_IMPORTED_MODULE_22__[\"OptionList\"](allChars, allChars.length - 1, true);\n                nameOption = new _OptionList__WEBPACK_IMPORTED_MODULE_22__[\"OptionList\"]([\n                    charOptions1,\n                    charOptions2,\n                    charOptions3,\n                    charOptions4,\n                    charOptions5,\n                    charOptions6\n                ], 0);\n                for (let i = 0; i < highScoreList.length; i++) {\n                    if (highScoreList[i].score < tetris.score) {\n                        highScore = highScoreList[i];\n                        hightScoreIndex = i;\n                        break;\n                    }\n                }\n                highScore.score = tetris.score;\n                highScore.level = tetris.level;\n                highScore.name = '------';\n                state = 5;\n            }\n            else {\n                tetris = new _TetrisGame__WEBPACK_IMPORTED_MODULE_17__[\"TetrisGame\"](context, imageSp, sm);\n                state = 0;\n            }\n        }\n        else if (state === 5) {\n            tetris = new _TetrisGame__WEBPACK_IMPORTED_MODULE_17__[\"TetrisGame\"](context, imageSp, sm);\n            state = 0;\n        }\n    }\n    // soft drop: arrow down\n    if (event.keyCode === 40) {\n        if (state === 4) {\n            // FIXME: remove this side effect code\n            // maybe use const fps with num of frames for timing?\n            tetris.nextDropTime = Date.now();\n            tetris.moveDown();\n        }\n        if (state === 2) {\n            musicTypeOptions.next();\n            sm.play(99);\n        }\n        if (state === 5) {\n            nameOption.getOption().previous();\n            const options = nameOption.getOptions();\n            let newName = '';\n            for (let i = 0; i < options.length; i++) {\n                newName += options[i].getOption();\n            }\n            highScore.name = newName;\n        }\n    }\n    // hard drop: space\n    if (event.keyCode === 32) {\n        if (state === 4) {\n            tetris.hardDrop();\n        }\n    }\n});\n\n\n//# sourceURL=webpack:///./src/index.ts?");

/***/ }),

/***/ "./src/sound/Sound.ts":
/*!****************************!*\
  !*** ./src/sound/Sound.ts ***!
  \****************************/
/*! exports provided: Sound */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Sound\", function() { return Sound; });\nvar Sound;\n(function (Sound) {\n    Sound[Sound[\"DROP\"] = 0] = \"DROP\";\n    Sound[Sound[\"ROTATION\"] = 1] = \"ROTATION\";\n    Sound[Sound[\"REMOVE_ROWS\"] = 2] = \"REMOVE_ROWS\";\n})(Sound || (Sound = {}));\n\n\n//# sourceURL=webpack:///./src/sound/Sound.ts?");

/***/ }),

/***/ "./src/sound/SoundManager.ts":
/*!***********************************!*\
  !*** ./src/sound/SoundManager.ts ***!
  \***********************************/
/*! exports provided: SoundManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SoundManager\", function() { return SoundManager; });\n/* harmony import */ var jsxm_xm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsxm/xm */ \"./node_modules/jsxm/xm.js\");\n/* harmony import */ var jsxm_xm__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jsxm_xm__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var jsxm_xmeffects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jsxm/xmeffects */ \"./node_modules/jsxm/xmeffects.js\");\n/* harmony import */ var jsxm_xmeffects__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jsxm_xmeffects__WEBPACK_IMPORTED_MODULE_1__);\n// import music from '../assets/music/4mat-truck_is_jarig.xm';\n// Side effect imports because jsxm exposes its player through a global scope object\n\n\nclass SoundManager {\n    constructor() {\n        this.sounds = new Map();\n        XMPlayer.init();\n        // this.audioContext = new AudioContext();\n        this.audioContext = XMPlayer.audioctx;\n        // this.playExtendedModule(music);\n    }\n    loadSound(sound, filename) {\n        return fetch(filename)\n            .then((response) => response.arrayBuffer())\n            .then((arrayBuffer) => this.audioContext.decodeAudioData(arrayBuffer))\n            .then((audioBuffer) => {\n            this.sounds.set(sound, audioBuffer);\n        });\n    }\n    loadExtendedModule(filename) {\n        return fetch(filename)\n            .then((response) => response.arrayBuffer());\n    }\n    playExtendedModule(filename) {\n        return fetch(filename)\n            .then((response) => response.arrayBuffer())\n            .then((arrayBuffer) => {\n            if (arrayBuffer) {\n                XMPlayer.load(arrayBuffer);\n                XMPlayer.play();\n            }\n            else {\n                console.log('unable to load', filename);\n            }\n        });\n    }\n    // TODO: check whether we have to dealocate the buffer and gain node?\n    play(sound) {\n        const source = this.audioContext.createBufferSource();\n        source.buffer = this.sounds.get(sound);\n        const gainNode = this.audioContext.createGain();\n        gainNode.gain.value = 0.3;\n        source.connect(gainNode);\n        gainNode.connect(this.audioContext.destination);\n        source.start();\n    }\n}\n\n\n//# sourceURL=webpack:///./src/sound/SoundManager.ts?");

/***/ })

/******/ });